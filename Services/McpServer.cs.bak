using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using CodeMerger.Models;
using CodeMerger.Services.Mcp;

namespace CodeMerger.Services
{
    /// <summary>
    /// MCP Server for CodeMerger - provides code analysis tools via Model Context Protocol.
    /// Coordinates tool handlers for read, write, semantic, refactoring, and workspace operations.
    /// </summary>
    public class McpServer
    {
        private readonly CodeAnalyzer _codeAnalyzer;
        private readonly IndexGenerator _indexGenerator;
        private readonly WorkspaceService _workspaceService;
        private CancellationTokenSource? _cancellationTokenSource;
        private Task? _serverTask;

        // Thread safety lock for workspace state
        private readonly object _stateLock = new object();

        // Background update control - prevents memory explosion from concurrent updates
        private readonly SemaphoreSlim _updateSemaphore = new SemaphoreSlim(1, 1);
        private readonly System.Collections.Concurrent.ConcurrentDictionary<string, DateTime> _pendingUpdates = new();
        private readonly TimeSpan _debounceDelay = TimeSpan.FromMilliseconds(500);
        private CodeAnalyzer? _updateAnalyzer; // Reusable analyzer for incremental updates

        // Workspace state
        private WorkspaceAnalysis? _workspaceAnalysis;
        private RefactoringService? _refactoringService;
        private List<CallSite> _callSites = new();
        private List<string> _inputDirectories = new();
        private string _workspaceName = string.Empty;

        // File scanning settings
        private List<string> _extensions = new();
        private HashSet<string> _ignoredDirs = new();

        // Tool handlers
        private McpReadToolHandler? _readHandler;
        private McpWriteToolHandler? _writeHandler;
        private McpSemanticToolHandler? _semanticHandler;
        private McpRefactoringToolHandler? _refactoringHandler;
        private McpWorkspaceToolHandler? _workspaceHandler;
        private McpLessonToolHandler? _lessonHandler;

        // Services
        private readonly LessonService _lessonService;

        public bool IsRunning => _serverTask != null && !_serverTask.IsCompleted;
        public event Action<string>? OnLog;

        public const string ActivityPipeName = "codemerger_activity";

        private static readonly JsonSerializerOptions JsonOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        public McpServer()
        {
            _codeAnalyzer = new CodeAnalyzer();
            _indexGenerator = new IndexGenerator();
            _workspaceService = new WorkspaceService();
            _lessonService = new LessonService();
        }

        public void IndexWorkspace(string workspaceName, List<string> inputDirectories, List<string> extensions, HashSet<string> ignoredDirs)
        {
            _workspaceName = workspaceName;
            _inputDirectories = inputDirectories;
            _extensions = extensions;
            _ignoredDirs = ignoredDirs;

            PerformIndexing();
        }

        /// <summary>
        /// Switches to a different workspace without restarting the server.
        /// Loads the new workspace config and re-indexes.
        /// </summary>
        public bool SwitchToWorkspace(string workspaceName)
        {
            var workspace = _workspaceService.LoadWorkspace(workspaceName);
            if (workspace == null)
            {
                Log($"SwitchToWorkspace failed: workspace '{workspaceName}' not found");
                return false;
            }

            Log($"Switching to workspace: {workspaceName}");

            // Parse extensions
            var extensions = workspace.Extensions
                .Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(ext => ext.Trim())
                .Where(ext => !string.IsNullOrEmpty(ext))
                .ToList();

            // Parse ignored directories
            var ignoredDirsInput = workspace.IgnoredDirectories + ",.git";
            var ignoredDirNames = ignoredDirsInput
                .Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(dir => dir.Trim().ToLowerInvariant())
                .ToHashSet();

            // Update instance state - filter out disabled directories
            _workspaceName = workspaceName;
            _inputDirectories = workspace.InputDirectories
                .Where(dir => !workspace.DisabledDirectories.Contains(dir))
                .ToList();
            _extensions = extensions;
            _ignoredDirs = ignoredDirNames;

            // Clear update state to free memory
            _updateAnalyzer = null;
            _pendingUpdates.Clear();

            // CRITICAL: Null out handlers FIRST to release references to old workspace
            _readHandler = null;
            _writeHandler = null;
            _semanticHandler = null;
            _refactoringHandler = null;
            _workspaceHandler = null;
            _refactoringService = null;

            // Clear old workspace data before creating new
            _workspaceAnalysis = null;
            _callSites.Clear();

            // Force GC NOW to release old workspace memory before loading new one
            GC.Collect(2, GCCollectionMode.Forced, blocking: true);

            // Set as active workspace
            _workspaceService.SetActiveWorkspace(workspaceName);

            // Re-index with new config
            PerformIndexing();

            LogWithMemory($"Switched to workspace: {workspaceName} ({_workspaceAnalysis?.TotalFiles ?? 0} files)");
            return true;
        }

        private List<string> ScanFiles()
        {
            return _inputDirectories
                .Where(Directory.Exists)
                .SelectMany(dir =>
                {
                    try
                    {
                        return Directory.EnumerateFiles(dir, "*", SearchOption.AllDirectories);
                    }
                    catch
                    {
                        return Enumerable.Empty<string>();
                    }
                })
                .Where(file =>
                {
                    var pathParts = file.Split(Path.DirectorySeparatorChar);
                    if (pathParts.Any(part => _ignoredDirs.Contains(part.ToLowerInvariant())))
                        return false;

                    var fileExtension = Path.GetExtension(file);
                    if (_extensions.Count == 0 || _extensions.Contains("*.*")) return true;
                    return _extensions.Contains(fileExtension, StringComparer.OrdinalIgnoreCase);
                })
                .Distinct()
                .ToList();
        }

        private void PerformIndexing()
        {
            lock (_stateLock)
            {
                // Rescan directories to discover new/deleted files
                var files = ScanFiles();

                Log($"Starting indexing of {files.Count} files...");

                // Clear previous call sites
                _codeAnalyzer.CallSites.Clear();
                _callSites.Clear();

                var fileAnalyses = new List<FileAnalysis>();
                int processed = 0;

                foreach (var file in files)
                {
                    var baseDir = _inputDirectories.FirstOrDefault(dir => file.StartsWith(dir, StringComparison.OrdinalIgnoreCase));
                    if (baseDir == null) continue;

                    var analysis = _codeAnalyzer.AnalyzeFile(file, baseDir);
                    fileAnalyses.Add(analysis);

                    processed++;

                    // For large projects, log progress and allow GC periodically
                    if (processed % 50 == 0)
                    {
                        Log($"Indexed {processed}/{files.Count} files...");
                        // Allow GC to clean up Roslyn syntax trees
                        GC.Collect(0, GCCollectionMode.Optimized, blocking: false);
                    }
                }

                // Store call sites for semantic analysis
                _callSites = _codeAnalyzer.CallSites.ToList();

                var chunkManager = new ChunkManager(150000);
                var chunks = chunkManager.CreateChunks(fileAnalyses);
                _workspaceAnalysis = _indexGenerator.BuildWorkspaceAnalysis(_workspaceName, fileAnalyses, chunks);

                // Initialize services and handlers
                _refactoringService = new RefactoringService(_workspaceAnalysis, _inputDirectories);
                InitializeHandlers();

                LogWithMemory($"Indexed {fileAnalyses.Count} files, {_workspaceAnalysis.TypeHierarchy.Count} types, {_callSites.Count} call sites");
            }
        }

        /// <summary>
        /// Incrementally updates a single file in the index without full re-indexing.
        /// Runs in background to avoid blocking MCP responses.
        /// Uses debouncing and a semaphore to prevent memory issues from rapid/concurrent updates.
        /// </summary>
        private void UpdateSingleFileAsync(string filePath)
        {
            var now = DateTime.UtcNow;
            _pendingUpdates[filePath] = now;

            // Fire and forget - but controlled by semaphore
            _ = Task.Run(async () =>
            {
                try
                {
                    // Wait for debounce period
                    await Task.Delay(_debounceDelay);

                    // Check if this is still the latest update request for this file
                    if (_pendingUpdates.TryGetValue(filePath, out var scheduledTime) && scheduledTime != now)
                    {
                        // A newer update was scheduled, skip this one
                        return;
                    }

                    // Remove from pending
                    _pendingUpdates.TryRemove(filePath, out _);

                    // Only one update at a time to prevent memory explosion
                    if (!await _updateSemaphore.WaitAsync(TimeSpan.FromSeconds(5)))
                    {
                        Log($"Skipped update for {Path.GetFileName(filePath)} - semaphore timeout");
                        return;
                    }

                    try
                    {
                        lock (_stateLock)
                        {
                            if (_workspaceAnalysis == null) return;

                            var baseDir = _inputDirectories.FirstOrDefault(dir =>
                                filePath.StartsWith(dir, StringComparison.OrdinalIgnoreCase));

                            if (baseDir == null) return;

                            // Remove old analysis for this file
                            var existingFile = _workspaceAnalysis.AllFiles
                                .FirstOrDefault(f => f.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase));

                            if (existingFile != null)
                            {
                                _workspaceAnalysis.AllFiles.Remove(existingFile);

                                // Remove old call sites from this file
                                _callSites.RemoveAll(cs => cs.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase));

                                // Remove old types from hierarchy
                                foreach (var type in existingFile.Types)
                                {
                                    _workspaceAnalysis.TypeHierarchy.Remove(type.Name);
                                }
                            }

                            // Re-analyze the single file
                            if (File.Exists(filePath))
                            {
                                // Reuse analyzer instance to avoid Roslyn memory accumulation
                                _updateAnalyzer ??= new CodeAnalyzer();
                                _updateAnalyzer.CallSites.Clear();

                                var newAnalysis = _updateAnalyzer.AnalyzeFile(filePath, baseDir);
                                _workspaceAnalysis.AllFiles.Add(newAnalysis);

                                // Add new call sites
                                _callSites.AddRange(_updateAnalyzer.CallSites);

                                // Update type hierarchy for types in this file
                                foreach (var type in newAnalysis.Types)
                                {
                                    var inheritance = new List<string>();
                                    if (!string.IsNullOrEmpty(type.BaseType))
                                        inheritance.Add(type.BaseType);
                                    inheritance.AddRange(type.Interfaces);
                                    _workspaceAnalysis.TypeHierarchy[type.Name] = inheritance;
                                }
                            }

                            Log($"Updated index for: {Path.GetFileName(filePath)}");
                        }
                    }
                    finally
                    {
                        _updateSemaphore.Release();
                    }
                }
                catch (Exception ex)
                {
                    Log($"Error updating index: {ex.Message}");
                }
            });
        }

        private void InitializeHandlers()
        {
            if (_workspaceAnalysis == null || _refactoringService == null) return;

            _readHandler = new McpReadToolHandler(_workspaceAnalysis, SendActivity);
            _writeHandler = new McpWriteToolHandler(_workspaceAnalysis, _refactoringService, _inputDirectories, UpdateSingleFileAsync, SendActivity, Log);
            _semanticHandler = new McpSemanticToolHandler(_workspaceAnalysis, _callSites, SendActivity);
            _refactoringHandler = new McpRefactoringToolHandler(_workspaceAnalysis, _refactoringService, _callSites, SendActivity, Log);
            _workspaceHandler = new McpWorkspaceToolHandler(
                _workspaceService,
                _workspaceName,
                _inputDirectories,
                () => PerformIndexing(), // Refresh callback
                () => RequestShutdown(), // Shutdown callback
                (name) => SwitchToWorkspace(name), // Switch workspace callback
                SendActivity,
                Log);
            _lessonHandler = new McpLessonToolHandler(_lessonService, SendActivity);
        }

        private void RequestShutdown()
        {
            SendDisconnect();
            _cancellationTokenSource?.Cancel();
            Task.Delay(200).ContinueWith(_ => Environment.Exit(0));
        }

        public async Task StartAsync(Stream inputStream, Stream outputStream)
        {
            _cancellationTokenSource = new CancellationTokenSource();
            var token = _cancellationTokenSource.Token;

            Log("MCP Server starting...");

            var parentMonitorTask = StartParentProcessMonitor(token);

            _serverTask = Task.Run(async () =>
            {
                using var reader = new StreamReader(inputStream, Encoding.UTF8);
                using var writer = new StreamWriter(outputStream, new UTF8Encoding(false)) { AutoFlush = true };

                while (!token.IsCancellationRequested)
                {
                    try
                    {
                        var line = await reader.ReadLineAsync();

                        if (line == null)
                        {
                            Log("Stdin closed (EOF detected) - client disconnected");
                            SendDisconnect();
                            break;
                        }

                        if (string.IsNullOrWhiteSpace(line)) continue;

                        var response = ProcessMessage(line);
                        if (response != null)
                        {
                            await writer.WriteLineAsync(response);
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        break;
                    }
                    catch (Exception ex)
                    {
                        Log($"Error: {ex.Message}");
                    }
                }

                Log("MCP Server stopped.");
            }, token);

            await _serverTask;
            _cancellationTokenSource.Cancel();
        }

        private Task StartParentProcessMonitor(CancellationToken token)
        {
            return Task.Run(async () =>
            {
                try
                {
                    var currentProcess = Process.GetCurrentProcess();
                    Process? parentProcess = null;

                    try
                    {
                        var parentId = GetParentProcessId(currentProcess.Id);
                        if (parentId > 0)
                        {
                            parentProcess = Process.GetProcessById(parentId);
                            Log($"Monitoring parent process: {parentProcess.ProcessName} (PID: {parentId})");
                        }
                    }
                    catch
                    {
                        Log("Could not determine parent process - skipping parent monitor");
                        return;
                    }

                    if (parentProcess == null) return;

                    while (!token.IsCancellationRequested)
                    {
                        await Task.Delay(10000, token);

                        try
                        {
                            if (parentProcess.HasExited)
                            {
                                Log("Parent process has exited - shutting down");
                                RequestShutdown();
                            }
                        }
                        catch
                        {
                            Log("Parent process no longer accessible - shutting down");
                            RequestShutdown();
                        }
                    }
                }
                catch (OperationCanceledException) { }
                catch (Exception ex)
                {
                    Log($"Parent monitor error: {ex.Message}");
                }
            }, token);
        }

        private static int GetParentProcessId(int processId)
        {
            try
            {
                using var query = new System.Management.ManagementObjectSearcher(
                    $"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {processId}");

                foreach (var item in query.Get())
                {
                    return Convert.ToInt32(item["ParentProcessId"]);
                }
            }
            catch { }

            return -1;
        }

        public void Stop()
        {
            SendDisconnect();
            _cancellationTokenSource?.Cancel();

            // Clean up update resources
            _updateAnalyzer = null;
            _pendingUpdates.Clear();

            Log("MCP Server stopping...");
        }

        private string? ProcessMessage(string message)
        {
            try
            {
                using var doc = JsonDocument.Parse(message);
                var root = doc.RootElement;

                var method = root.GetProperty("method").GetString();
                var id = root.TryGetProperty("id", out var idProp) ? idProp.GetInt32() : 0;

                Log($"Received: {method}");

                return method switch
                {
                    "initialize" => HandleInitialize(id),
                    "tools/list" => HandleListTools(id),
                    "tools/call" => HandleToolCall(id, root),
                    "notifications/initialized" => null,
                    _ => CreateErrorResponse(id, -32601, $"Method not found: {method}")
                };
            }
            catch (Exception ex)
            {
                Log($"Parse error: {ex.Message}");
                return CreateErrorResponse(0, -32700, "Parse error");
            }
        }

        private string HandleInitialize(int id)
        {
            var response = new
            {
                jsonrpc = "2.0",
                id,
                result = new
                {
                    protocolVersion = "2024-11-05",
                    capabilities = new { tools = new { } },
                    serverInfo = new { name = "codemerger-mcp", version = "2.0.0" }
                }
            };
            return JsonSerializer.Serialize(response, JsonOptions);
        }

        private string HandleListTools(int id)
        {
            var tools = McpToolRegistry.GetAllTools();
            var response = new
            {
                jsonrpc = "2.0",
                id,
                result = new { tools }
            };
            return JsonSerializer.Serialize(response, JsonOptions);
        }

        private string HandleToolCall(int id, JsonElement root)
        {
            var paramsEl = root.GetProperty("params");
            var toolName = paramsEl.GetProperty("name").GetString() ?? "";
            var arguments = paramsEl.TryGetProperty("arguments", out var argsEl) ? argsEl : default;

            Log($"Tool call: {toolName}");
            SendActivity($"Tool: {toolName}");

            // Server control tools don't require workspace
            if (toolName == "codemerger_shutdown")
                return CreateToolResponse(id, _workspaceHandler?.Shutdown() ?? HandleShutdownFallback());

            if (toolName == "codemerger_list_projects")
                return CreateToolResponse(id, _workspaceHandler?.ListWorkspaces() ?? HandleListWorkspacesFallback());

            if (toolName == "codemerger_switch_project")
                return CreateToolResponse(id, _workspaceHandler?.SwitchWorkspace(arguments) ?? "Error: Handler not initialized");

            if (toolName == "codemerger_refresh")
                return CreateToolResponse(id, _workspaceHandler?.Refresh() ?? "Error: Handler not initialized");

            if (toolName == "codemerger_build")
                return CreateToolResponse(id, _workspaceHandler?.Build(arguments) ?? "Error: Handler not initialized");

            // Lesson tools don't require workspace
            if (toolName == "codemerger_log_lesson")
                return CreateToolResponse(id, HandleLessonTool("log", arguments));

            if (toolName == "codemerger_get_lessons")
                return CreateToolResponse(id, HandleLessonTool("get", arguments));

            if (toolName == "codemerger_delete_lesson")
                return CreateToolResponse(id, HandleLessonTool("delete", arguments));

            // All other tools require workspace
            if (_workspaceAnalysis == null)
            {
                return CreateToolResponse(id, "Error: No workspace indexed. Please select a workspace in CodeMerger first.");
            }

            var result = DispatchToolCall(toolName, arguments);
            return CreateToolResponse(id, result);
        }

        private string DispatchToolCall(string toolName, JsonElement arguments)
        {
            // Note: No lock here - read operations are safe, write operations
            // trigger PerformIndexing() which has its own lock for state mutation
            return toolName switch
            {
                // Read tools
                "codemerger_get_project_overview" => _readHandler!.GetWorkspaceOverview(),
                "codemerger_list_files" => _readHandler!.ListFiles(arguments),
                "codemerger_get_file" => _readHandler!.GetFile(arguments),
                "codemerger_search_code" => _readHandler!.SearchCode(arguments),
                "codemerger_get_type" => _readHandler!.GetType(arguments),
                "codemerger_get_dependencies" => _readHandler!.GetDependencies(arguments),
                "codemerger_get_type_hierarchy" => _readHandler!.GetTypeHierarchy(),
                "codemerger_grep" => _readHandler!.Grep(arguments),
                "codemerger_get_context" => _readHandler!.GetContext(arguments),
                "codemerger_get_lines" => _readHandler!.GetLines(arguments),

                // Semantic tools
                "codemerger_find_references" => _semanticHandler!.FindReferences(arguments),
                "codemerger_get_callers" => _semanticHandler!.GetCallers(arguments),
                "codemerger_get_callees" => _semanticHandler!.GetCallees(arguments),
                "codemerger_get_diagnostics" => _semanticHandler!.GetDiagnostics(arguments),

                // Write tools
                "codemerger_str_replace" => _writeHandler!.StrReplace(arguments),
                "codemerger_write_file" => _writeHandler!.WriteFile(arguments),
                "codemerger_preview_write" => _writeHandler!.PreviewWriteFile(arguments),
                "codemerger_delete_file" => _writeHandler!.DeleteFile(arguments),
                "codemerger_undo" => _writeHandler!.Undo(arguments),
                "codemerger_move_file" => _writeHandler!.MoveFile(arguments),

                // Refactoring tools
                "codemerger_rename_symbol" => _refactoringHandler!.RenameSymbol(arguments),
                "codemerger_generate_interface" => _refactoringHandler!.GenerateInterface(arguments),
                "codemerger_extract_method" => _refactoringHandler!.ExtractMethod(arguments),
                "codemerger_add_parameter" => _refactoringHandler!.AddParameter(arguments),
                "codemerger_implement_interface" => _refactoringHandler!.ImplementInterface(arguments),
                "codemerger_generate_constructor" => _refactoringHandler!.GenerateConstructor(arguments),

                _ => $"Unknown tool: {toolName}"
            };
        }

        // Fallbacks for when handlers aren't initialized
        private string HandleShutdownFallback()
        {
            Task.Run(async () =>
            {
                await Task.Delay(500);
                SendDisconnect();
                _cancellationTokenSource?.Cancel();
                await Task.Delay(200);
                Environment.Exit(0);
            });
            return "# Server Shutdown\n\nCodeMerger MCP server is shutting down.";
        }

        private string HandleListWorkspacesFallback()
        {
            var workspaces = _workspaceService.LoadAllWorkspaces();
            if (workspaces.Count == 0)
                return "# Available Workspaces\n\nNo workspaces found.";

            var sb = new StringBuilder();
            sb.AppendLine("# Available Workspaces\n");
            foreach (var w in workspaces)
                sb.AppendLine($"- {w.Name}");
            return sb.ToString();
        }

        private string HandleLessonTool(string action, JsonElement arguments)
        {
            // Initialize lesson handler if needed (doesn't require workspace)
            _lessonHandler ??= new McpLessonToolHandler(_lessonService, SendActivity);

            return action switch
            {
                "log" => _lessonHandler.LogLesson(arguments),
                "get" => _lessonHandler.GetLessons(),
                "delete" => _lessonHandler.DeleteLesson(arguments),
                _ => "Error: Unknown lesson action"
            };
        }

        private string CreateToolResponse(int id, string content)
        {
            var response = new
            {
                jsonrpc = "2.0",
                id,
                result = new
                {
                    content = new[] { new { type = "text", text = content } }
                }
            };
            return JsonSerializer.Serialize(response, JsonOptions);
        }

        private string CreateErrorResponse(int id, int code, string message)
        {
            var response = new
            {
                jsonrpc = "2.0",
                id,
                error = new { code, message }
            };
            return JsonSerializer.Serialize(response, JsonOptions);
        }

        private void Log(string message)
        {
            OnLog?.Invoke($"[MCP] {message}");
        }

        private void LogWithMemory(string message)
        {
            var memMB = GC.GetTotalMemory(false) / 1024 / 1024;
            OnLog?.Invoke($"[MCP] {message} (Mem: {memMB}MB)");
        }

        private void SendActivity(string activity)
        {
            Task.Run(() =>
            {
                try
                {
                    using var pipe = new NamedPipeClientStream(".", ActivityPipeName, PipeDirection.Out);
                    pipe.Connect(100);
                    using var writer = new StreamWriter(pipe);
                    writer.WriteLine($"{_workspaceName}|{activity}");
                    writer.Flush();
                }
                catch { }
            });
        }

        private void SendDisconnect()
        {
            try
            {
                using var pipe = new NamedPipeClientStream(".", ActivityPipeName, PipeDirection.Out);
                pipe.Connect(200);
                using var writer = new StreamWriter(pipe);
                writer.WriteLine($"{_workspaceName}|DISCONNECT");
                writer.Flush();
            }
            catch { }
        }
    }
}
