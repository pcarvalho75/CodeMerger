using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CodeMerger.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeMerger.Services
{
    /// <summary>
    /// Provides refactoring and code modification capabilities.
    /// </summary>
    public class RefactoringService
    {
        private readonly WorkspaceAnalysis _workspaceAnalysis;
        private readonly List<string> _inputDirectories;
        private readonly WorkspaceSettings _settings;

        public RefactoringService(WorkspaceAnalysis workspaceAnalysis, List<string> inputDirectories, WorkspaceSettings? settings = null)
        {
            _workspaceAnalysis = workspaceAnalysis;
            _inputDirectories = inputDirectories;
            _settings = settings ?? WorkspaceSettings.GetDefaultSettings();
        }

        /// <summary>
        /// Write content to a file (create or overwrite).
        /// Supports ../ paths to write to sibling projects within the workspace.
        /// </summary>
        public WriteFileResult WriteFile(string relativePath, string content, bool? createBackup = null)
        {
            // Use settings default if not explicitly specified
            var shouldBackup = createBackup ?? _settings.CreateBackupFiles;
            
            var result = new WriteFileResult { RelativePath = relativePath };

            try
            {
                // Security: Validate path has no dangerous characters
                if (!IsPathSafe(relativePath))
                {
                    result.Success = false;
                    result.Error = "Invalid path: contains invalid characters";
                    return result;
                }

                string fullPath;
                FileAnalysis? existingFile = null;

                // Try to match path prefix to a known project root
                string baseDir;
                string effectivePath = relativePath;
                
                var matchedRoot = _inputDirectories.FirstOrDefault(dir =>
                {
                    var rootName = Path.GetFileName(dir.TrimEnd('\\', '/'));
                    return relativePath.StartsWith(rootName + "/", StringComparison.OrdinalIgnoreCase) ||
                           relativePath.StartsWith(rootName + "\\", StringComparison.OrdinalIgnoreCase);
                });

                if (matchedRoot != null)
                {
                    // Path starts with a root name like "Vortex/Engines/file.cs"
                    // Use that root and strip the prefix
                    baseDir = matchedRoot;
                    var rootName = Path.GetFileName(matchedRoot.TrimEnd('\\', '/'));
                    effectivePath = relativePath.Substring(rootName.Length + 1); // +1 for the separator
                }
                else
                {
                    // No root prefix - use first directory (original behavior)
                    baseDir = _inputDirectories.FirstOrDefault() ?? Directory.GetCurrentDirectory();
                }

                fullPath = Path.GetFullPath(Path.Combine(baseDir, effectivePath.Replace('/', Path.DirectorySeparatorChar)));

                // Security: Verify resolved path is within workspace
                if (!IsPathWithinWorkspace(fullPath))
                {
                    result.Success = false;
                    result.Error = $"Invalid path: resolved path escapes workspace. Valid roots: {string.Join(", ", _inputDirectories.Select(d => Path.GetFileName(d.TrimEnd('\\', '/'))))}";
                    return result;
                }

                // Check if file exists - match by full path OR relative path
                existingFile = _workspaceAnalysis.AllFiles.FirstOrDefault(f =>
                    f.FilePath.Equals(fullPath, StringComparison.OrdinalIgnoreCase) ||
                    f.RelativePath.Equals(relativePath, StringComparison.OrdinalIgnoreCase) ||
                    f.RelativePath.Replace('\\', '/').Equals(relativePath.Replace('\\', '/'), StringComparison.OrdinalIgnoreCase));

                // SAFETY CHECK: If creating a NEW file with multiple roots and no explicit root prefix,
                // require explicit project specification to avoid accidentally creating in wrong location
                if (existingFile == null && matchedRoot == null && _inputDirectories.Count > 1)
                {
                    var rootNames = _inputDirectories.Select(d => Path.GetFileName(d.TrimEnd('\\', '/'))).ToList();
                    result.Success = false;
                    result.Error = $"Ambiguous target: This workspace has multiple project roots and the path '{relativePath}' doesn't specify which one.\n\n" +
                                $"**Available roots:** {string.Join(", ", rootNames)}\n\n" +
                                $"**Please prefix your path with the target project**, e.g.:\n" +
                                string.Join("\n", rootNames.Take(3).Select(r => $"- `{r}/{relativePath}`"));
                    return result;
                }

                if (existingFile != null)
                {
                    fullPath = existingFile.FilePath;
                    result.IsNewFile = false;

                    // Create backup
                    if (createBackup && File.Exists(fullPath))
                    {
                        var backupPath = fullPath + ".bak";
                        File.Copy(fullPath, backupPath, overwrite: true);
                        result.BackupPath = backupPath;
                    }

                    // Generate diff
                    var oldContent = File.ReadAllText(fullPath);
                    result.Diff = GenerateDiff(oldContent, content, existingFile.RelativePath);
                }
                else
                {
                    result.IsNewFile = true;

                    // Ensure directory exists
                    var dir = Path.GetDirectoryName(fullPath);
                    if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
                    {
                        Directory.CreateDirectory(dir);
                    }
                }

                // Write the file atomically
                WriteFileAtomic(fullPath, content);
                result.FullPath = fullPath;
                result.Success = true;
                result.BytesWritten = content.Length;
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Error = ex.Message;
            }

            return result;
        }

        /// <summary>
        /// Check if a relative path is safe (no dangerous characters).
        /// Note: Path traversal (..) is allowed - security is enforced by IsPathWithinWorkspace().
        /// </summary>
        private bool IsPathSafe(string relativePath)
        {
            if (string.IsNullOrWhiteSpace(relativePath))
                return false;

            // Reject absolute paths
            if (Path.IsPathRooted(relativePath))
                return false;

            // Reject paths with null bytes or other dangerous characters
            if (relativePath.Contains('\0'))
                return false;

            return true;
        }

        /// <summary>
        /// Check if a fully resolved path is within one of the workspace directories.
        /// </summary>
        private bool IsPathWithinWorkspace(string fullPath)
        {
            var normalizedPath = Path.GetFullPath(fullPath);
            
            foreach (var inputDir in _inputDirectories)
            {
                var normalizedDir = Path.GetFullPath(inputDir);
                if (!normalizedDir.EndsWith(Path.DirectorySeparatorChar.ToString()))
                    normalizedDir += Path.DirectorySeparatorChar;

                if (normalizedPath.StartsWith(normalizedDir, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Write file atomically: write to temp file, then move to target.
        /// Prevents corruption if process crashes mid-write.
        /// </summary>
        private void WriteFileAtomic(string targetPath, string content)
        {
            var dir = Path.GetDirectoryName(targetPath) ?? ".";
            var tempPath = Path.Combine(dir, $".{Path.GetFileName(targetPath)}.{Guid.NewGuid():N}.tmp");

            try
            {
                // Write to temp file
                File.WriteAllText(tempPath, content);

                // Atomic move (replace if exists)
                File.Move(tempPath, targetPath, overwrite: true);
            }
            finally
            {
                // Clean up temp file if it still exists (move failed)
                if (File.Exists(tempPath))
                {
                    try { File.Delete(tempPath); } catch { }
                }
            }
        }

        /// <summary>
        /// Preview what a file write would look like without actually writing.
        /// </summary>
        public WriteFileResult PreviewWriteFile(string relativePath, string content)
        {
            var result = new WriteFileResult
            {
                RelativePath = relativePath,
                IsPreview = true
            };

            var existingFile = _workspaceAnalysis.AllFiles
                .FirstOrDefault(f => f.RelativePath.Equals(relativePath, StringComparison.OrdinalIgnoreCase) ||
                                    f.RelativePath.Replace('\\', '/').Equals(relativePath.Replace('\\', '/'), StringComparison.OrdinalIgnoreCase));

            if (existingFile != null)
            {
                result.IsNewFile = false;
                var oldContent = File.ReadAllText(existingFile.FilePath);
                result.Diff = GenerateDiff(oldContent, content, relativePath);
            }
            else
            {
                result.IsNewFile = true;
                result.Diff = $"+++ {relativePath} (new file)\n{content}";
            }

            result.Success = true;
            return result;
        }

        /// <summary>
        /// Rename a symbol across all files.
        /// </summary>
        public RenameResult RenameSymbol(string oldName, string newName, bool preview = true)
        {
            var result = new RenameResult
            {
                OldName = oldName,
                NewName = newName,
                IsPreview = preview
            };

            var affectedFiles = new Dictionary<string, RenameFileChange>();

            foreach (var file in _workspaceAnalysis.AllFiles.Where(f => f.Extension == ".cs"))
            {
                try
                {
                    var content = File.ReadAllText(file.FilePath);

                    // Use word boundary matching to avoid partial replacements
                    var pattern = $@"\b{Regex.Escape(oldName)}\b";
                    var matches = Regex.Matches(content, pattern);

                    if (matches.Count > 0)
                    {
                        var newContent = Regex.Replace(content, pattern, newName);

                        affectedFiles[file.RelativePath] = new RenameFileChange
                        {
                            FilePath = file.RelativePath,
                            FullPath = file.FilePath,
                            OccurrenceCount = matches.Count,
                            Diff = GenerateDiff(content, newContent, file.RelativePath)
                        };

                        if (!preview)
                        {
                            // Create backup only if settings allow
                            if (_settings.CreateBackupFiles)
                                File.Copy(file.FilePath, file.FilePath + ".bak", overwrite: true);
                            File.WriteAllText(file.FilePath, newContent);
                        }
                    }
                }
                catch (Exception ex)
                {
                    result.Errors.Add($"{file.RelativePath}: {ex.Message}");
                }
            }

            result.AffectedFiles = affectedFiles.Values.ToList();
            result.TotalOccurrences = affectedFiles.Values.Sum(f => f.OccurrenceCount);
            result.Success = !result.Errors.Any();

            return result;
        }

        /// <summary>
        /// Generate an interface from a class's public members.
        /// </summary>
        public GenerateInterfaceResult GenerateInterface(string className, string? interfaceName = null)
        {
            var result = new GenerateInterfaceResult { ClassName = className };

            // Find the class
            var classFile = _workspaceAnalysis.AllFiles
                .SelectMany(f => f.Types.Select(t => new { File = f, Type = t }))
                .FirstOrDefault(x => x.Type.Name.Equals(className, StringComparison.OrdinalIgnoreCase));

            if (classFile == null)
            {
                result.Error = $"Class '{className}' not found";
                return result;
            }

            var type = classFile.Type;
            var file = classFile.File;

            interfaceName ??= $"I{className}";
            result.InterfaceName = interfaceName;

            var sb = new StringBuilder();

            // Get namespace from file
            try
            {
                var content = File.ReadAllText(file.FilePath);
                var tree = CSharpSyntaxTree.ParseText(content);
                var root = tree.GetCompilationUnitRoot();
                var ns = root.DescendantNodes().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();

                if (ns != null)
                {
                    sb.AppendLine($"namespace {ns.Name}");
                    sb.AppendLine("{");
                }

                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Interface for {className}");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public interface {interfaceName}");
                sb.AppendLine("    {");

                // Add public methods and properties
                foreach (var member in type.Members.Where(m => m.AccessModifier == "public"))
                {
                    if (member.Kind == CodeMemberKind.Method && member.Name != className) // Skip constructors
                    {
                        var asyncMod = member.IsAsync ? "" : ""; // Interface doesn't need async keyword, just Task return
                        sb.AppendLine($"        {member.ReturnType} {member.Signature};");
                    }
                    else if (member.Kind == CodeMemberKind.Property)
                    {
                        sb.AppendLine($"        {member.ReturnType} {member.Name} {{ get; set; }}");
                    }
                }

                sb.AppendLine("    }");

                if (ns != null)
                {
                    sb.AppendLine("}");
                }
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
                return result;
            }

            result.GeneratedCode = sb.ToString();
            result.SuggestedFilePath = Path.Combine(
                Path.GetDirectoryName(file.RelativePath) ?? "",
                $"{interfaceName}.cs"
            );
            result.Success = true;

            return result;
        }

        /// <summary>
        /// Extract code into a new method.
        /// </summary>
        public ExtractMethodResult ExtractMethod(string filePath, int startLine, int endLine, string newMethodName)
        {
            var result = new ExtractMethodResult
            {
                FilePath = filePath,
                NewMethodName = newMethodName
            };

            var file = _workspaceAnalysis.AllFiles
                .FirstOrDefault(f => f.RelativePath.Equals(filePath, StringComparison.OrdinalIgnoreCase));

            if (file == null)
            {
                result.Error = $"File '{filePath}' not found";
                return result;
            }

            try
            {
                var lines = File.ReadAllLines(file.FilePath).ToList();

                if (startLine < 1 || endLine > lines.Count || startLine > endLine)
                {
                    result.Error = $"Invalid line range: {startLine}-{endLine}";
                    return result;
                }

                // Extract the lines
                var extractedLines = lines.Skip(startLine - 1).Take(endLine - startLine + 1).ToList();
                var extractedCode = string.Join(Environment.NewLine, extractedLines);

                // Detect indentation
                var baseIndent = extractedLines.FirstOrDefault()?.TakeWhile(char.IsWhiteSpace).Count() ?? 8;
                var methodIndent = new string(' ', baseIndent);
                var bodyIndent = new string(' ', baseIndent + 4);

                // Build new method
                var newMethod = new StringBuilder();
                newMethod.AppendLine();
                newMethod.AppendLine($"{methodIndent}private void {newMethodName}()");
                newMethod.AppendLine($"{methodIndent}{{");
                foreach (var line in extractedLines)
                {
                    newMethod.AppendLine(line);
                }
                newMethod.AppendLine($"{methodIndent}}}");

                // Replace extracted code with method call
                var callIndent = new string(' ', baseIndent);
                lines.RemoveRange(startLine - 1, endLine - startLine + 1);
                lines.Insert(startLine - 1, $"{callIndent}{newMethodName}();");

                // Find where to insert the new method (after the current class's closing brace area)
                // Simple approach: insert at end of file before last }
                var insertIndex = lines.Count - 1;
                for (int i = lines.Count - 1; i >= 0; i--)
                {
                    if (lines[i].Trim() == "}")
                    {
                        insertIndex = i;
                        break;
                    }
                }

                lines.Insert(insertIndex, newMethod.ToString());

                result.ModifiedContent = string.Join(Environment.NewLine, lines);
                result.ExtractedCode = extractedCode;
                result.MethodCall = $"{newMethodName}();";
                result.Success = true;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }

            return result;
        }

        /// <summary>
        /// Generate a proper unified diff with context and hunks.
        /// </summary>
        private string GenerateDiff(string oldContent, string newContent, string fileName)
        {
            var oldLines = oldContent.Split('\n').Select(l => l.TrimEnd('\r')).ToArray();
            var newLines = newContent.Split('\n').Select(l => l.TrimEnd('\r')).ToArray();

            var sb = new StringBuilder();
            sb.AppendLine($"--- a/{fileName}");
            sb.AppendLine($"+++ b/{fileName}");

            // Find all differences using LCS-based approach
            var hunks = ComputeHunks(oldLines, newLines, contextLines: 3);

            foreach (var hunk in hunks)
            {
                sb.AppendLine($"@@ -{hunk.OldStart},{hunk.OldCount} +{hunk.NewStart},{hunk.NewCount} @@");
                foreach (var line in hunk.Lines)
                {
                    sb.AppendLine(line);
                }
            }

            return sb.ToString();
        }

        private List<DiffHunk> ComputeHunks(string[] oldLines, string[] newLines, int contextLines)
        {
            var hunks = new List<DiffHunk>();
            var changes = ComputeChanges(oldLines, newLines);

            if (changes.Count == 0)
                return hunks;

            // Group changes into hunks with context
            int i = 0;
            while (i < changes.Count)
            {
                var hunk = new DiffHunk();
                var hunkLines = new List<string>();

                // Find the start of this change group
                int changeStart = changes[i].OldIndex;
                int hunkOldStart = Math.Max(0, changeStart - contextLines);
                int hunkNewStart = Math.Max(0, changes[i].NewIndex - contextLines);

                // Add leading context
                for (int c = hunkOldStart; c < changeStart && c < oldLines.Length; c++)
                {
                    hunkLines.Add(" " + oldLines[c]);
                }

                // Process changes until we hit a gap larger than 2*contextLines
                while (i < changes.Count)
                {
                    var change = changes[i];

                    // Check if there's a gap to the next change
                    if (i > 0)
                    {
                        var prevChange = changes[i - 1];
                        int gap = change.OldIndex - (prevChange.OldIndex + (prevChange.Type == ChangeType.Delete ? 1 : 0));
                        
                        if (gap > contextLines * 2)
                        {
                            // Add trailing context for previous group and start new hunk
                            break;
                        }

                        // Add context between changes
                        int contextStart = prevChange.OldIndex + (prevChange.Type == ChangeType.Delete ? 1 : 0);
                        for (int c = contextStart; c < change.OldIndex && c < oldLines.Length; c++)
                        {
                            hunkLines.Add(" " + oldLines[c]);
                        }
                    }

                    // Add the change itself
                    if (change.Type == ChangeType.Delete)
                    {
                        hunkLines.Add("-" + oldLines[change.OldIndex]);
                    }
                    else if (change.Type == ChangeType.Insert)
                    {
                        hunkLines.Add("+" + newLines[change.NewIndex]);
                    }

                    i++;
                }

                // Add trailing context
                int lastChangeOldIdx = i > 0 ? changes[i - 1].OldIndex : 0;
                int trailingStart = lastChangeOldIdx + 1;
                int trailingEnd = Math.Min(oldLines.Length, trailingStart + contextLines);
                for (int c = trailingStart; c < trailingEnd; c++)
                {
                    hunkLines.Add(" " + oldLines[c]);
                }

                // Calculate hunk header numbers
                int oldCount = hunkLines.Count(l => l.StartsWith(" ") || l.StartsWith("-"));
                int newCount = hunkLines.Count(l => l.StartsWith(" ") || l.StartsWith("+"));

                hunk.OldStart = hunkOldStart + 1; // 1-indexed
                hunk.OldCount = oldCount;
                hunk.NewStart = hunkNewStart + 1;
                hunk.NewCount = newCount;
                hunk.Lines = hunkLines;

                hunks.Add(hunk);
            }

            return hunks;
        }

        private List<Change> ComputeChanges(string[] oldLines, string[] newLines)
        {
            var changes = new List<Change>();

            // Simple LCS-based diff
            int[,] lcs = new int[oldLines.Length + 1, newLines.Length + 1];

            for (int i = 1; i <= oldLines.Length; i++)
            {
                for (int j = 1; j <= newLines.Length; j++)
                {
                    if (oldLines[i - 1] == newLines[j - 1])
                        lcs[i, j] = lcs[i - 1, j - 1] + 1;
                    else
                        lcs[i, j] = Math.Max(lcs[i - 1, j], lcs[i, j - 1]);
                }
            }

            // Backtrack to find changes
            int oi = oldLines.Length;
            int ni = newLines.Length;
            var tempChanges = new List<Change>();

            while (oi > 0 || ni > 0)
            {
                if (oi > 0 && ni > 0 && oldLines[oi - 1] == newLines[ni - 1])
                {
                    oi--;
                    ni--;
                }
                else if (ni > 0 && (oi == 0 || lcs[oi, ni - 1] >= lcs[oi - 1, ni]))
                {
                    tempChanges.Add(new Change { Type = ChangeType.Insert, OldIndex = oi, NewIndex = ni - 1 });
                    ni--;
                }
                else if (oi > 0)
                {
                    tempChanges.Add(new Change { Type = ChangeType.Delete, OldIndex = oi - 1, NewIndex = ni });
                    oi--;
                }
            }

            tempChanges.Reverse();
            return tempChanges;
        }

        private class DiffHunk
        {
            public int OldStart { get; set; }
            public int OldCount { get; set; }
            public int NewStart { get; set; }
            public int NewCount { get; set; }
            public List<string> Lines { get; set; } = new();
        }

        private class Change
        {
            public ChangeType Type { get; set; }
            public int OldIndex { get; set; }
            public int NewIndex { get; set; }
        }

        private enum ChangeType { Delete, Insert }
    }

    #region Result Models

    public class WriteFileResult
    {
        public string RelativePath { get; set; } = string.Empty;
        public string FullPath { get; set; } = string.Empty;
        public bool Success { get; set; }
        public bool IsNewFile { get; set; }
        public bool IsPreview { get; set; }
        public string? BackupPath { get; set; }
        public string? Error { get; set; }
        public string? Diff { get; set; }
        public int BytesWritten { get; set; }

        public string ToMarkdown()
        {
            var sb = new StringBuilder();

            if (IsPreview)
            {
                sb.AppendLine("# Write File Preview");
            }
            else
            {
                sb.AppendLine("# Write File Result");
            }
            sb.AppendLine();

            if (Success)
            {
                sb.AppendLine($"**File:** `{RelativePath}`");
                sb.AppendLine($"**Status:** {(IsNewFile ? "Created" : "Updated")}");

                if (!IsPreview)
                {
                    sb.AppendLine($"**Bytes written:** {BytesWritten}");
                    if (!string.IsNullOrEmpty(BackupPath))
                    {
                        sb.AppendLine($"**Backup:** `{BackupPath}`");
                    }
                }

                if (!string.IsNullOrEmpty(Diff))
                {
                    sb.AppendLine();
                    sb.AppendLine("## Changes");
                    sb.AppendLine("```diff");
                    sb.AppendLine(Diff);
                    sb.AppendLine("```");
                }
            }
            else
            {
                sb.AppendLine($"**Error:** {Error}");
            }

            return sb.ToString();
        }
    }

    public class RenameResult
    {
        public string OldName { get; set; } = string.Empty;
        public string NewName { get; set; } = string.Empty;
        public bool IsPreview { get; set; }
        public bool Success { get; set; }
        public List<RenameFileChange> AffectedFiles { get; set; } = new();
        public int TotalOccurrences { get; set; }
        public List<string> Errors { get; set; } = new();

        public string ToMarkdown()
        {
            var sb = new StringBuilder();

            sb.AppendLine(IsPreview ? "# Rename Preview" : "# Rename Result");
            sb.AppendLine();
            sb.AppendLine($"**Rename:** `{OldName}` â†’ `{NewName}`");
            sb.AppendLine($"**Total occurrences:** {TotalOccurrences} in {AffectedFiles.Count} files");
            sb.AppendLine();

            if (AffectedFiles.Any())
            {
                sb.AppendLine("## Affected Files");
                foreach (var file in AffectedFiles)
                {
                    sb.AppendLine($"### `{file.FilePath}` ({file.OccurrenceCount} occurrences)");
                    if (!string.IsNullOrEmpty(file.Diff))
                    {
                        sb.AppendLine("```diff");
                        // Only show first 50 lines of diff
                        var diffLines = file.Diff.Split('\n').Take(50);
                        sb.AppendLine(string.Join("\n", diffLines));
                        sb.AppendLine("```");
                    }
                    sb.AppendLine();
                }
            }

            if (Errors.Any())
            {
                sb.AppendLine("## Errors");
                foreach (var error in Errors)
                {
                    sb.AppendLine($"- {error}");
                }
            }

            return sb.ToString();
        }
    }

    public class RenameFileChange
    {
        public string FilePath { get; set; } = string.Empty;
        public string FullPath { get; set; } = string.Empty;
        public int OccurrenceCount { get; set; }
        public string Diff { get; set; } = string.Empty;
    }

    public class GenerateInterfaceResult
    {
        public string ClassName { get; set; } = string.Empty;
        public string InterfaceName { get; set; } = string.Empty;
        public bool Success { get; set; }
        public string? Error { get; set; }
        public string GeneratedCode { get; set; } = string.Empty;
        public string SuggestedFilePath { get; set; } = string.Empty;

        public string ToMarkdown()
        {
            var sb = new StringBuilder();
            sb.AppendLine($"# Generate Interface: `{InterfaceName}`");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(Error))
            {
                sb.AppendLine($"**Error:** {Error}");
                return sb.ToString();
            }

            sb.AppendLine($"**From class:** `{ClassName}`");
            sb.AppendLine($"**Suggested file:** `{SuggestedFilePath}`");
            sb.AppendLine();
            sb.AppendLine("## Generated Code");
            sb.AppendLine("```csharp");
            sb.AppendLine(GeneratedCode);
            sb.AppendLine("```");

            return sb.ToString();
        }
    }

    public class ExtractMethodResult
    {
        public string FilePath { get; set; } = string.Empty;
        public string NewMethodName { get; set; } = string.Empty;
        public bool Success { get; set; }
        public string? Error { get; set; }
        public string ExtractedCode { get; set; } = string.Empty;
        public string MethodCall { get; set; } = string.Empty;
        public string ModifiedContent { get; set; } = string.Empty;

        public string ToMarkdown()
        {
            var sb = new StringBuilder();
            sb.AppendLine($"# Extract Method: `{NewMethodName}`");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(Error))
            {
                sb.AppendLine($"**Error:** {Error}");
                return sb.ToString();
            }

            sb.AppendLine($"**File:** `{FilePath}`");
            sb.AppendLine($"**Method call:** `{MethodCall}`");
            sb.AppendLine();

            sb.AppendLine("## Extracted Code");
            sb.AppendLine("```csharp");
            sb.AppendLine(ExtractedCode);
            sb.AppendLine("```");

            sb.AppendLine();
            sb.AppendLine("*Use `codemerger_write_file` with the modified content to apply this change.*");

            return sb.ToString();
        }
    }

    #endregion
}
