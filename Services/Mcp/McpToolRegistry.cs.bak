using System;
using System.Collections.Generic;

namespace CodeMerger.Services.Mcp
{
    /// <summary>
    /// Centralized registry for all MCP tool definitions.
    ///
    /// TOOL CATEGORIES:
    ///
    /// EXPLORATION (start here):
    ///   get_project_overview → list_files → get_type / get_file
    ///   get_context (AI-ranked files for a task, with call-graph expansion)
    ///
    /// SEARCHING:
    ///   search_code - semantic (type/method names)
    ///   grep - literal text patterns
    ///   find_references - all usages of a symbol
    ///
    /// UNDERSTANDING:
    ///   get_type - class structure
    ///   get_dependencies - what uses/is used by a type
    ///   get_callers/get_callees - call graph
    ///   get_type_hierarchy - inheritance
    ///
    /// EDITING:
    ///   str_replace - surgical edits (preferred)
    ///   write_file - full file writes
    ///   get_lines - see exact content before editing
    ///   preview_write - preview changes before writing
    ///
    /// REFACTORING:
    ///   rename_symbol - rename across project
    ///   move_file - move with reference updates
    ///   add_parameter - add param, update call sites
    ///   extract_method, generate_interface, generate_constructor, implement_interface
    ///
    /// VALIDATION:
    ///   get_diagnostics - Roslyn analysis for compile errors
    ///   build - full dotnet build with NuGet/XAML
    ///
    /// RECOVERY:
    ///   undo - restore from .bak
    ///
    /// SERVER:
    ///   refresh, shutdown, list_projects, switch_project
    ///
    /// MAINTENANCE:
    ///   clean_backups - delete all .bak files (preview first, then confirm)
    ///   find_duplicates - find duplicate code for refactoring opportunities
    ///
    /// SELF-IMPROVEMENT:
    ///   log_lesson - log observation when something could be improved
    ///   get_lessons - view all logged lessons
    ///   delete_lesson - clear lessons after applying improvements
    /// </summary>
    public static class McpToolRegistry
    {
        public static object[] GetAllTools()
        {
            var tools = new List<object>();
            tools.AddRange(GetReadTools());
            tools.AddRange(GetWriteTools());
            tools.AddRange(GetRefactoringTools());
            tools.AddRange(GetSemanticTools());
            tools.AddRange(GetServerControlTools());
            tools.AddRange(GetMaintenanceTools());
            tools.AddRange(GetLessonTools());
            tools.AddRange(GetNotesTools());
            tools.AddRange(GetGitTools());
            return tools.ToArray();
        }

        private static object[] GetReadTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_get_project_overview",
                    description = "Get high-level project information including framework, structure, namespaces, total files, and entry points.\n\n" +
                        "WHEN TO USE: Call this first when starting work on a project to understand its structure.\n\n" +
                        "EXPLORATION PATHS:\n" +
                        "- For general exploration: get_project_overview → list_files → get_type/get_file\n" +
                        "- For task-based work: get_context (uses call-graph analysis to find relevant files)\n\n" +
                        "Follow up with `list_files` filtered by namespace to explore specific areas.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_list_files",
                    description = "List all files in the project with their namespaces, classifications (View, Model, Service, etc.) and estimated tokens.\n\n" +
                        "WHEN TO USE: After `get_project_overview`, use this to drill into specific namespaces or file types. Filter by 'namespace' for architectural exploration, by 'classification' to find all Services/Models/Views.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "classification", new Dictionary<string, string> { { "type", "string" }, { "description", "Filter by classification: View, Model, Service, Controller, Test, Config, Unknown" } } },
                                { "namespace", new Dictionary<string, string> { { "type", "string" }, { "description", "Filter by namespace (partial match supported)" } } },
                                { "limit", new Dictionary<string, string> { { "type", "integer" }, { "description", "Maximum files to return (default 50)" } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_get_file",
                    description = "Get the full content of a specific file by its relative path.\n\n" +
                        "WHEN TO USE: When you need to see complete file content. For large files (>300 lines), prefer `get_lines` to read specific sections.\n" +
                        "BEFORE EDITING: Always verify current state with this or `get_lines` before using `str_replace` — never assume content hasn't changed.\n" +
                        "FOR CHANGES: Prefer `str_replace` for surgical edits rather than rewriting entire files with `write_file`.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file" } } }
                            }
                        },
                        { "required", new[] { "path" } }
                    }
                },
                new
                {
                    name = "codemerger_search_code",
                    description = "Search for types, methods, namespaces, or keywords in the indexed codebase.\n\n" +
                        "WHEN TO USE: For finding where something is defined — type names, method names, namespaces. This searches the semantic index.\n" +
                        "VS GREP: Use `grep` instead for literal text patterns, string values, comments, or content that isn't a symbol name.\n" +
                        "VS GET_CONTEXT: Use `get_context` when you have a task description and want AI-ranked relevant files.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "query", new Dictionary<string, string> { { "type", "string" }, { "description", "Search query (type name, method name, namespace, or keyword)" } } },
                                { "searchIn", new Dictionary<string, string> { { "type", "string" }, { "description", "Where to search: types, methods, files, namespaces, all (default: all)" } } }
                            }
                        },
                        { "required", new[] { "query" } }
                    }
                },
                new
                {
                    name = "codemerger_get_type",
                    description = "Get detailed information about a specific type including its members, base types, and interfaces.\n\n" +
                        "WHEN TO USE: Before modifying a class — understand its structure, what it inherits, what interfaces it implements.\n" +
                        "NEXT STEP: If planning to change this type, call `get_dependencies` to see what would be affected.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "typeName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the type" } } }
                            }
                        },
                        { "required", new[] { "typeName" } }
                    }
                },
                new
                {
                    name = "codemerger_get_dependencies",
                    description = "Get dependencies of a type (what it uses) and reverse dependencies (what uses it).\n\n" +
                        "WHEN TO USE: ESSENTIAL before any refactoring — renaming, moving, changing signatures. Shows impact scope.\n" +
                        "RULE: Always call this before `rename_symbol`, `move_file`, or modifying public members.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "typeName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the type" } } }
                            }
                        },
                        { "required", new[] { "typeName" } }
                    }
                },
                new
                {
                    name = "codemerger_get_type_hierarchy",
                    description = "Get the inheritance hierarchy for all types in the project.\n\n" +
                        "WHEN TO USE: Understanding class relationships, finding base classes, seeing interface implementations across the codebase.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_grep",
                    description = "Search file contents using regex or plain text. Returns matches with line numbers and context.\n\n" +
                        "WHEN TO USE: For literal text patterns, string values, comments, error messages, TODO markers, or anything that isn't a symbol name.\n" +
                        "VS SEARCH_CODE: Use `search_code` for type/method names. Use `grep` for actual text content.\n" +
                        "EXAMPLES: Find all TODO comments, search for a specific error string, find hardcoded values.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "pattern", new Dictionary<string, string> { { "type", "string" }, { "description", "Search pattern (regex or plain text)" } } },
                                { "isRegex", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Treat pattern as regex (default: true)" }, { "default", true } } },
                                { "caseSensitive", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Case-sensitive search (default: false)" }, { "default", false } } },
                                { "contextLines", new Dictionary<string, object> { { "type", "integer" }, { "description", "Lines of context before/after match (default: 2)" }, { "default", 2 } } },
                                { "maxResults", new Dictionary<string, object> { { "type", "integer" }, { "description", "Maximum results to return (default: 50)" }, { "default", 50 } } }
                            }
                        },
                        { "required", new[] { "pattern" } }
                    }
                },
                new
                {
                    name = "codemerger_get_context",
                    description = "Intelligently analyze a task description and return relevant files ranked by relevance.\n\n" +
                        "START HERE: For new tasks, describe what you want to do in natural language.\n\n" +
                        "SMART FEATURES:\n" +
                        "- Keyword extraction from task description\n" +
                        "- Type/method name matching\n" +
                        "- Classification-aware scoring (Service, Model, View)\n" +
                        "- **Call graph expansion**: Automatically includes files containing callers/callees of matched code\n" +
                        "- Token budget optimization\n\n" +
                        "WHEN TO USE:\n" +
                        "- Starting a new task and don't know which files to look at\n" +
                        "- Need complete context including related code paths\n" +
                        "- More efficient than manual `search_code` + `grep` combinations\n\n" +
                        "EXAMPLES: 'add a new MCP tool', 'fix the grid trading logic', 'implement caching for the workspace'.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "task", new Dictionary<string, string> { { "type", "string" }, { "description", "Natural language description of what you want to do (e.g., 'add validation to user input', 'implement new MCP tool')" } } },
                                { "maxFiles", new Dictionary<string, object> { { "type", "integer" }, { "description", "Maximum files to return (default: 10). Increase for complex tasks that touch many files." }, { "default", 10 } } },
                                { "maxTokens", new Dictionary<string, object> { { "type", "integer" }, { "description", "Maximum total tokens (default: 50000). The tool reserves 30% of budget for call-graph expanded files." }, { "default", 50000 } } }
                            }
                        },
                        { "required", new[] { "task" } }
                    }
                },
                new
                {
                    name = "codemerger_get_lines",
                    description = "Get raw lines from a file with ALL whitespace made visible (tabs as →, spaces as ·).\n\n" +
                        "WHEN TO USE:\n" +
                        "1. When `str_replace` fails with 'not found' — see exact whitespace to fix your search string\n" +
                        "2. For large files — read specific sections instead of loading entire file with `get_file`\n" +
                        "3. Before editing — verify exact current content at specific line numbers\n" +
                        "RECOVERY: If `str_replace` fails, call this with the line numbers from the error, then copy exact content.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file" } } },
                                { "startLine", new Dictionary<string, object> { { "type", "integer" }, { "description", "First line to retrieve (1-indexed)" } } },
                                { "endLine", new Dictionary<string, object> { { "type", "integer" }, { "description", "Last line to retrieve (1-indexed, default: startLine + 20)" } } }
                            }
                        },
                        { "required", new[] { "path", "startLine" } }
                    }
                }
            };
        }

        private static object[] GetSemanticTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_find_references",
                    description = "Find all references to a symbol (type, method, property) using semantic analysis.\n\n" +
                        "WHEN TO USE: To see everywhere a symbol is used — definitions, invocations, implementations.\n" +
                        "VS GREP: This uses semantic analysis (understands code structure), while `grep` is just text search.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "symbolName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the symbol to find references for" } } },
                                { "symbolKind", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: type, method, property, field to narrow search" } } }
                            }
                        },
                        { "required", new[] { "symbolName" } }
                    }
                },
                new
                {
                    name = "codemerger_get_callers",
                    description = "Get all methods that call a specific method.\n\n" +
                        "WHEN TO USE: Before modifying a method's signature or behavior — see what code depends on it.\n" +
                        "PART OF: Call graph analysis. Pair with `get_callees` for full picture.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "methodName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the method to find callers for" } } },
                                { "typeName", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: type containing the method to narrow search" } } }
                            }
                        },
                        { "required", new[] { "methodName" } }
                    }
                },
                new
                {
                    name = "codemerger_get_callees",
                    description = "Get all methods that a specific method calls.\n\n" +
                        "WHEN TO USE: Understanding what a method depends on — useful for understanding complex methods.\n" +
                        "PART OF: Call graph analysis. Pair with `get_callers` for full picture.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "methodName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the method to find callees for" } } },
                                { "typeName", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: type containing the method to narrow search" } } }
                            }
                        },
                        { "required", new[] { "methodName" } }
                    }
                },
                new
                {
                    name = "codemerger_get_diagnostics",
                    description = "Get compilation errors and warnings for the project using Roslyn.\n\n" +
                        "WHEN TO USE: After making changes — verify the code still compiles correctly.\n" +
                        "TIP: Run this after a series of edits to catch any issues before the user tries to build.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: specific file path to check. If omitted, checks all C# files." } } },
                                { "errorsOnly", new Dictionary<string, object> { { "type", "boolean" }, { "description", "If true, only show errors (not warnings). Default: false" }, { "default", false } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                }
            };
        }

        private static object[] GetWriteTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_str_replace",
                    description = "Replace a unique string in a file with another string. The oldStr must appear exactly once in the file.\n\n" +
                        "PREFERRED: Use this for surgical edits instead of rewriting entire files with `write_file`.\n" +
                        "DELETE: Set newStr to empty string to delete the match.\n\n" +
                        "IF IT FAILS ('not found'):\n" +
                        "1. Call `get_lines` with line numbers from the error to see exact whitespace\n" +
                        "2. Copy the exact content including whitespace\n" +
                        "3. Never guess — always verify current file state first\n\n" +
                        "NUGET PACKAGES (.csproj files):\n" +
                        "Before adding a PackageReference, use `grep` to search for existing references to that package.\n" +
                        "If found, preserve the existing version unless explicitly asked to change it.\n\n" +
                        "WORKFLOW - Before making ANY file modifications:\n" +
                        "1. Present a roadmap of all planned changes to the user\n" +
                        "2. Ask: 'Proceed with AUTOMATIC editing (I'll make all changes), or STEP-BY-STEP (I'll show each change for your approval)?'\n" +
                        "3. If STEP-BY-STEP: Show the original code and proposed new code in chat, wait for user to say OK before calling this tool\n" +
                        "4. Only call this tool AFTER user confirms the change\n" +
                        "5. If AUTOMATIC: Proceed with all changes after initial roadmap approval",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file" } } },
                                { "oldStr", new Dictionary<string, string> { { "type", "string" }, { "description", "String to find and replace (must be unique in file)" } } },
                                { "newStr", new Dictionary<string, string> { { "type", "string" }, { "description", "Replacement string (empty to delete)" } } },
                                { "createBackup", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Create .bak backup before modifying (default: true)" }, { "default", true } } },
                            { "normalizeIndent", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Ignore leading whitespace differences when matching (default: false). Use when exact indentation match fails." }, { "default", false } } }
                            }
                        },
                        { "required", new[] { "path", "oldStr" } }
                    }
                },
                new
                {
                    name = "codemerger_write_file",
                    description = "Write content to a file (create new or overwrite existing). Creates a .bak backup before overwriting.\n\n" +
                        "WHEN TO USE: Creating new files, or when changes are so extensive that `str_replace` isn't practical.\n" +
                        "PREFER: `str_replace` for small/medium changes — it's safer and preserves more context.\n" +
                        "TIP: Use `preview_write` first to see a diff of what will change.\n\n" +
                        "WORKFLOW - Before making ANY file modifications:\n" +
                        "1. Present a roadmap of all planned changes to the user\n" +
                        "2. Ask: 'Proceed with AUTOMATIC editing (I'll make all changes), or STEP-BY-STEP (I'll show each change for your approval)?'\n" +
                        "3. If STEP-BY-STEP: Show the proposed file content in chat, wait for user to say OK before calling this tool\n" +
                        "4. Only call this tool AFTER user confirms the change\n" +
                        "5. If AUTOMATIC: Proceed with all changes after initial roadmap approval",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file (e.g., 'Services/MyService.cs')" } } },
                                { "content", new Dictionary<string, string> { { "type", "string" }, { "description", "Complete file content to write" } } },
                                { "createBackup", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Create .bak backup before overwriting (default: true)" }, { "default", true } } }
                            }
                        },
                        { "required", new[] { "path", "content" } }
                    }
                },
                new
                {
                    name = "codemerger_preview_write",
                    description = "Preview what a file write would look like without actually writing. Shows a diff of changes.\n\n" +
                        "WHEN TO USE: Before `write_file` to verify your changes are correct. Especially useful for large rewrites.\n" +
                        "SAFE: No changes are made — purely informational.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file" } } },
                                { "content", new Dictionary<string, string> { { "type", "string" }, { "description", "Complete file content to preview" } } }
                            }
                        },
                        { "required", new[] { "path", "content" } }
                    }
                },
                new
                {
                    name = "codemerger_delete_file",
                    description = "Delete a file from the project. Creates a .bak backup before deleting.\n\n" +
                        "RECOVERABLE: Use `undo` to restore the file from the .bak backup.\n" +
                        "CAUTION: Check `get_dependencies` first to ensure nothing depends on types in this file.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file to delete" } } }
                            }
                        },
                        { "required", new[] { "path" } }
                    }
                },
                new
                {
                    name = "codemerger_undo",
                    description = "Restore a file from its .bak backup.\n\n" +
                        "WHEN TO USE: After `str_replace`, `write_file`, or `delete_file` made unwanted changes.\n" +
                        "LIMITATION: Only restores the most recent backup — multiple sequential edits overwrite previous backups.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "path", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file to restore" } } }
                            }
                        },
                        { "required", new[] { "path" } }
                    }
                },
                new
                {
                    name = "codemerger_move_file",
                    description = "Move or rename a file and update all using statements and references across the project.\n\n" +
                        "BEFORE USING: Call `get_dependencies` to understand what will be affected.\n" +
                        "PREVIEW FIRST: Always run with preview=true first to see all affected files.\n" +
                        "BACKUPS: Creates backups of all modified files.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "oldPath", new Dictionary<string, string> { { "type", "string" }, { "description", "Current relative path of the file" } } },
                                { "newPath", new Dictionary<string, string> { { "type", "string" }, { "description", "New relative path for the file" } } },
                                { "preview", new Dictionary<string, object> { { "type", "boolean" }, { "description", "If true, only show what would change without applying (default: true)" }, { "default", true } } }
                            }
                        },
                        { "required", new[] { "oldPath", "newPath" } }
                    }
                }
            };
        }

        private static object[] GetRefactoringTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_rename_symbol",
                    description = "Rename a symbol (class, method, variable) across all files in the project.\n\n" +
                        "BEFORE USING: ALWAYS call `get_dependencies` first to understand the scope of impact.\n" +
                        "PREVIEW FIRST: Always run with preview=true to see all affected locations.\n\n" +
                        "WORKFLOW:\n" +
                        "1. Call `get_dependencies` on the type containing the symbol\n" +
                        "2. Run with preview=true and show results to user\n" +
                        "3. Ask user to confirm before running with preview=false\n" +
                        "4. Only set preview=false AFTER user explicitly approves",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "oldName", new Dictionary<string, string> { { "type", "string" }, { "description", "Current name of the symbol" } } },
                                { "newName", new Dictionary<string, string> { { "type", "string" }, { "description", "New name for the symbol" } } },
                                { "preview", new Dictionary<string, object> { { "type", "boolean" }, { "description", "If true, only show what would change without applying (default: true)" }, { "default", true } } }
                            }
                        },
                        { "required", new[] { "oldName", "newName" } }
                    }
                },
                new
                {
                    name = "codemerger_generate_interface",
                    description = "Generate an interface from a class's public members.\n\n" +
                        "RETURNS: Generated code — you must then write it to a file using `write_file`.\n" +
                        "NEXT STEP: After creating the interface file, update the class to implement it.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "className", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the class to extract interface from" } } },
                                { "interfaceName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name for the generated interface (default: I{ClassName})" } } }
                            }
                        },
                        { "required", new[] { "className" } }
                    }
                },
                new
                {
                    name = "codemerger_extract_method",
                    description = "Extract a range of lines into a new method.\n\n" +
                        "RETURNS: Modified file content — you must then write it using `write_file`.\n" +
                        "TIP: Use `get_lines` first to identify the exact line range to extract.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "filePath", new Dictionary<string, string> { { "type", "string" }, { "description", "Relative path to the file" } } },
                                { "startLine", new Dictionary<string, string> { { "type", "integer" }, { "description", "First line to extract (1-indexed)" } } },
                                { "endLine", new Dictionary<string, string> { { "type", "integer" }, { "description", "Last line to extract (1-indexed)" } } },
                                { "methodName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name for the new method" } } }
                            }
                        },
                        { "required", new[] { "filePath", "startLine", "endLine", "methodName" } }
                    }
                },
                new
                {
                    name = "codemerger_add_parameter",
                    description = "Add a parameter to a method and update all call sites.\n\n" +
                        "BEFORE USING: Call `get_callers` to see all places that call this method.\n" +
                        "PREVIEW FIRST: Always run with preview=true to see all affected call sites.\n\n" +
                        "WORKFLOW:\n" +
                        "1. Run with preview=true and show results to user\n" +
                        "2. Ask user to confirm before running with preview=false\n" +
                        "3. Only set preview=false AFTER user explicitly approves",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "typeName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the type containing the method" } } },
                                { "methodName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the method to add parameter to" } } },
                                { "parameterType", new Dictionary<string, string> { { "type", "string" }, { "description", "Type of the new parameter (e.g., 'string', 'int', 'bool')" } } },
                                { "parameterName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the new parameter" } } },
                                { "defaultValue", new Dictionary<string, string> { { "type", "string" }, { "description", "Default value for the parameter at call sites (e.g., 'null', '0', 'true')" } } },
                                { "preview", new Dictionary<string, object> { { "type", "boolean" }, { "description", "If true, only show what would change without applying (default: true)" }, { "default", true } } }
                            }
                        },
                        { "required", new[] { "typeName", "methodName", "parameterType", "parameterName", "defaultValue" } }
                    }
                },
                new
                {
                    name = "codemerger_implement_interface",
                    description = "Generate stub implementations for all members of an interface in a class.\n\n" +
                        "RETURNS: Code to add — you must insert it into the class using `str_replace`.\n" +
                        "TIP: Use `get_type` on the interface first to see what members will be generated.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "className", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the class that should implement the interface" } } },
                                { "interfaceName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the interface to implement" } } }
                            }
                        },
                        { "required", new[] { "className", "interfaceName" } }
                    }
                },
                new
                {
                    name = "codemerger_generate_constructor",
                    description = "Generate a constructor that initializes selected fields/properties of a class.\n\n" +
                        "RETURNS: Constructor code — you must insert it into the class using `str_replace`.\n" +
                        "TIP: Use `get_type` first to see available fields/properties.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "className", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the class to generate constructor for" } } },
                                { "fields", new Dictionary<string, object> { { "type", "array" }, { "items", new Dictionary<string, string> { { "type", "string" } } }, { "description", "Optional: specific field/property names to include. If empty, includes all fields and properties." } } }
                            }
                        },
                        { "required", new[] { "className" } }
                    }
                }
            };
        }

        private static object[] GetServerControlTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_build",
                    description = "Run `dotnet build` on the project and return real compilation results.\n\n" +
                        "WHEN TO USE: After making changes — verify the code compiles correctly with full NuGet resolution and XAML compilation.\n" +
                        "BETTER THAN get_diagnostics: Uses actual MSBuild, handles NuGet packages, XAML, all project references.\n" +
                        "NOTE: Takes 10-30 seconds depending on project size.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "configuration", new Dictionary<string, object> { { "type", "string" }, { "description", "Build configuration: Debug or Release (default: Debug)" }, { "default", "Debug" } } },
                                { "verbose", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Include full build output (default: false)" }, { "default", false } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_refresh",
                    description = "Refresh the workspace index by re-analyzing all files.\n\n" +
                        "WHEN TO USE: After external changes (user edited files outside of MCP tools) — ensures index is up to date.\n" +
                        "NOT NEEDED: After using MCP write tools — they automatically update the index for modified files.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_shutdown",
                    description = "Shutdown the CodeMerger MCP server.\n\n" +
                        "WHEN TO USE: When user needs to recompile the project in Visual Studio, or wants to stop the server.\n" +
                        "EFFECT: Server exits and releases all file locks.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_list_projects",
                    description = "List all available CodeMerger projects.\n\n" +
                        "SHOWS: Project names and which one is currently active/loaded.\n" +
                        "NEXT STEP: Use `switch_project` to change to a different project.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_switch_project",
                    description = "Switch to a different CodeMerger project.\n\n" +
                        "HOT-SWAP: Server re-indexes the new workspace without restarting — no reconnection needed.\n" +
                        "FIRST: Use `list_projects` to see available projects.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "projectName", new Dictionary<string, string> { { "type", "string" }, { "description", "Name of the project to switch to" } } }
                            }
                        },
                        { "required", new[] { "projectName" } }
                    }
                }
            };
        }

        private static object[] GetMaintenanceTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_clean_backups",
                    description = "Delete all .bak backup files from the workspace.\n\n" +
                        "WHEN TO USE: Only when user explicitly asks to clean up backup files, free disk space, or mentions '.bak' files.\n" +
                        "WORKFLOW:\n" +
                        "1. First call WITHOUT confirm parameter to preview what would be deleted\n" +
                        "2. Show user the count, size, and folder breakdown\n" +
                        "3. Only call with `confirm: true` AFTER user approves\n\n" +
                        "NEVER auto-confirm - always preview first and wait for user approval.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "confirm", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Must be true to actually delete. If false or omitted, only shows what would be deleted." } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_find_duplicates",
                    description = "Find duplicate or highly similar code blocks across the codebase.\n\n" +
                        "WHEN TO USE:\n" +
                        "- User asks about code quality, technical debt, or refactoring opportunities\n" +
                        "- User wants to reduce code duplication\n" +
                        "- Before major refactoring to identify consolidation targets\n" +
                        "- User asks 'what can be improved' or 'find repeated code'\n\n" +
                        "RETURNS: Clusters ranked by impact (most duplicated first), with:\n" +
                        "- Similarity percentage\n" +
                        "- File locations and line numbers\n" +
                        "- Code snippet preview\n" +
                        "- Potential lines saved if refactored\n\n" +
                        "FOLLOW-UP: Use `extract_method` to refactor the highest-impact duplicates.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "minLines", new Dictionary<string, object> { { "type", "integer" }, { "description", "Minimum lines for a code block to be considered (default: 5)" }, { "default", 5 } } },
                                { "minSimilarity", new Dictionary<string, object> { { "type", "integer" }, { "description", "Minimum similarity percentage 0-100 (default: 80). Use 90+ for near-exact matches, 70 for loose similarity." }, { "default", 80 } } },
                                { "maxResults", new Dictionary<string, object> { { "type", "integer" }, { "description", "Maximum duplicate clusters to return (default: 20)" }, { "default", 20 } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                }
            };
        }

        private static object[] GetLessonTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_log_lesson",
                    description = "Log a self-improvement observation when something could be done better.\n\n" +
                        "WHEN TO USE: Call this when you notice:\n" +
                        "- A tool description was unclear or misleading\n" +
                        "- A workflow was inefficient (had to use multiple tools when one would be better)\n" +
                        "- Error handling could be improved\n" +
                        "- A new tool or feature would help\n" +
                        "- Code in CodeMerger itself could be optimized\n\n" +
                        "LIMIT: Maximum 10 lessons stored. If full, ask user to review and clear lessons.\n" +
                        "TYPES: description | implementation | new_tool | workflow | performance | error_handling",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "type", new Dictionary<string, string> { { "type", "string" }, { "description", "Category: description, implementation, new_tool, workflow, performance, error_handling" } } },
                                { "component", new Dictionary<string, string> { { "type", "string" }, { "description", "Which component is affected (e.g., McpToolRegistry, McpWriteToolHandler, str_replace, NEW)" } } },
                                { "observation", new Dictionary<string, string> { { "type", "string" }, { "description", "What happened or what you noticed" } } },
                                { "proposal", new Dictionary<string, string> { { "type", "string" }, { "description", "How it could be improved" } } },
                                { "suggestedCode", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: code snippet showing the improvement" } } }
                            }
                        },
                        { "required", new[] { "type", "component", "observation", "proposal" } }
                    }
                },
                new
                {
                    name = "codemerger_get_lessons",
                    description = "Get all logged self-improvement lessons.\n\n" +
                        "WHEN TO USE: When user asks 'what did you learn?' or 'show improvements' or 'what can be improved?'\n" +
                        "NEXT STEPS: Review lessons with user, apply improvements using code editing tools, then clear lessons.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_delete_lesson",
                    description = "Delete a specific lesson or all lessons.\n\n" +
                        "WHEN TO USE: After improvements have been applied, or if user wants to discard lessons.\n" +
                        "OPTIONS: Provide 'number' (1-10) to delete one, or 'all: true' to clear all.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "number", new Dictionary<string, object> { { "type", "integer" }, { "description", "Lesson number to delete (1-10)" } } },
                                { "all", new Dictionary<string, object> { { "type", "boolean" }, { "description", "Set to true to delete all lessons" } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                }
            };
        }

        private static object[] GetNotesTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_get_notes",
                    description = "Get the current project notes.\n\n" +
                        "WHEN TO USE: To see what context has been saved about this project.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_add_note",
                    description = "Add a timestamped note to the project notes.\n\n" +
                        "WHEN TO USE: When you notice something important — roadmap items, decisions, context.\n" +
                        "SECTION: Optionally specify a section to organize notes.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "note", new Dictionary<string, string> { { "type", "string" }, { "description", "The note content to add" } } },
                                { "section", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional section name (e.g., Roadmap, Decisions, Context)" } } }
                            }
                        },
                        { "required", new[] { "note" } }
                    }
                },
                new
                {
                    name = "codemerger_update_note",
                    description = "Update or replace an entire section in the project notes.\n\n" +
                        "WHEN TO USE: When a section needs to be rewritten.\n" +
                        "CREATES: If the section doesn't exist, it will be created.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "section", new Dictionary<string, string> { { "type", "string" }, { "description", "Section name to update" } } },
                                { "content", new Dictionary<string, string> { { "type", "string" }, { "description", "New content for the section" } } }
                            }
                        },
                        { "required", new[] { "section", "content" } }
                    }
                },
                new
                {
                    name = "codemerger_clear_notes",
                    description = "Clear all notes or a specific section.\n\n" +
                        "CAUTION: Without a section specified, deletes ALL notes.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "section", new Dictionary<string, string> { { "type", "string" }, { "description", "Optional: specific section to clear" } } }
                            }
                        },
                        { "required", Array.Empty<string>() }
                    }
                }
            };
        }

        private static object[] GetGitTools()
        {
            return new object[]
            {
                new
                {
                    name = "codemerger_git_status",
                    description = "Get the current git status (modified, staged, untracked files).\n\n" +
                        "WHEN TO USE: Before committing to see what has changed.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_git_commit",
                    description = "Stage all changes and commit with a message.\n\n" +
                        "WHEN TO USE: To save changes locally without pushing.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "message", new Dictionary<string, string> { { "type", "string" }, { "description", "Commit message" } } }
                            }
                        },
                        { "required", new[] { "message" } }
                    }
                },
                new
                {
                    name = "codemerger_git_push",
                    description = "Push committed changes to remote.\n\n" +
                        "WHEN TO USE: After committing to sync with remote repository.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>() },
                        { "required", Array.Empty<string>() }
                    }
                },
                new
                {
                    name = "codemerger_git_commit_push",
                    description = "Stage all changes, commit, and push in one operation.\n\n" +
                        "WHEN TO USE: Quick way to save and sync all changes to remote.",
                    inputSchema = new Dictionary<string, object>
                    {
                        { "type", "object" },
                        { "properties", new Dictionary<string, object>
                            {
                                { "message", new Dictionary<string, string> { { "type", "string" }, { "description", "Commit message" } } }
                            }
                        },
                        { "required", new[] { "message" } }
                    }
                }
            };
        }
    }
}
