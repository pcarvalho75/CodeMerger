using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using CodeMerger.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace CodeMerger.Services.Mcp
{
    /// <summary>
    /// Handles semantic analysis MCP tools (find references, call graph, diagnostics).
    /// </summary>
    public class McpSemanticToolHandler
    {
        private readonly WorkspaceAnalysis _workspaceAnalysis;
        private readonly SemanticAnalyzer _semanticAnalyzer;
        private readonly Action<string> _sendActivity;

        public McpSemanticToolHandler(WorkspaceAnalysis workspaceAnalysis, List<CallSite> callSites, Action<string> sendActivity)
        {
            _workspaceAnalysis = workspaceAnalysis;
            _semanticAnalyzer = new SemanticAnalyzer(workspaceAnalysis, callSites);
            _sendActivity = sendActivity;
        }

        public string FindReferences(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("symbolName", out var symbolEl))
            {
                return "Error: 'symbolName' parameter is required.";
            }

            var symbolName = symbolEl.GetString() ?? "";
            _sendActivity($"Finding references: {symbolName}");

            string? symbolKind = null;
            if (arguments.TryGetProperty("symbolKind", out var kindEl))
                symbolKind = kindEl.GetString();

            var result = _semanticAnalyzer.FindUsages(symbolName, symbolKind);
            return result.ToMarkdown();
        }

        public string GetCallers(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("methodName", out var methodEl))
            {
                return "Error: 'methodName' parameter is required.";
            }

            var methodName = methodEl.GetString() ?? "";
            _sendActivity($"Finding callers of: {methodName}");

            string typeName = "";
            if (arguments.TryGetProperty("typeName", out var typeEl))
                typeName = typeEl.GetString() ?? "";

            var result = _semanticAnalyzer.GetCallGraph(typeName, methodName, 2);

            var sb = new StringBuilder();
            sb.AppendLine($"# Callers of `{(string.IsNullOrEmpty(typeName) ? "" : typeName + ".")}{methodName}`");
            sb.AppendLine();

            if (result.Callers.Any())
            {
                sb.AppendLine($"**Found:** {result.Callers.Count} callers");
                sb.AppendLine();
                sb.AppendLine("| Caller | File | Line |");
                sb.AppendLine("|--------|------|------|");

                foreach (var caller in result.Callers)
                {
                    sb.AppendLine($"| `{caller.TypeName}.{caller.MethodName}` | `{caller.FilePath}` | {caller.Line} |");
                }

                // Show upstream callers if available
                var upstreamCallers = result.Callers.Where(c => c.UpstreamCallers?.Any() == true).ToList();
                if (upstreamCallers.Any())
                {
                    sb.AppendLine();
                    sb.AppendLine("## Upstream Call Chain");
                    foreach (var caller in upstreamCallers)
                    {
                        sb.AppendLine($"- `{caller.TypeName}.{caller.MethodName}` is called by:");
                        foreach (var upstream in caller.UpstreamCallers!)
                        {
                            sb.AppendLine($"  - `{upstream}`");
                        }
                    }
                }
            }
            else
            {
                sb.AppendLine("*No callers found. This may be an entry point or unused method.*");
            }

            return sb.ToString();
        }

        public string GetCallees(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("methodName", out var methodEl))
            {
                return "Error: 'methodName' parameter is required.";
            }

            var methodName = methodEl.GetString() ?? "";
            _sendActivity($"Finding calls from: {methodName}");

            string typeName = "";
            if (arguments.TryGetProperty("typeName", out var typeEl))
                typeName = typeEl.GetString() ?? "";

            var result = _semanticAnalyzer.GetCallGraph(typeName, methodName, 2);

            var sb = new StringBuilder();
            sb.AppendLine($"# Methods called by `{(string.IsNullOrEmpty(typeName) ? "" : typeName + ".")}{methodName}`");
            sb.AppendLine();

            if (result.Callees.Any())
            {
                sb.AppendLine($"**Found:** {result.Callees.Count} calls");
                sb.AppendLine();
                sb.AppendLine("| Called Method | File | Line |");
                sb.AppendLine("|---------------|------|------|");

                foreach (var callee in result.Callees)
                {
                    sb.AppendLine($"| `{callee.TypeName}.{callee.MethodName}` | `{callee.FilePath}` | {callee.Line} |");
                }

                // Show downstream calls if available
                var downstreamCallees = result.Callees.Where(c => c.DownstreamCallees?.Any() == true).ToList();
                if (downstreamCallees.Any())
                {
                    sb.AppendLine();
                    sb.AppendLine("## Downstream Call Chain");
                    foreach (var callee in downstreamCallees)
                    {
                        sb.AppendLine($"- `{callee.TypeName}.{callee.MethodName}` calls:");
                        foreach (var downstream in callee.DownstreamCallees!)
                        {
                            sb.AppendLine($"  - `{downstream}`");
                        }
                    }
                }
            }
            else
            {
                sb.AppendLine("*No outgoing calls found.*");
            }

            return sb.ToString();
        }

        public string GetDiagnostics(JsonElement arguments)
        {
            string? specificPath = null;
            if (arguments.TryGetProperty("path", out var pathEl))
                specificPath = pathEl.GetString();

            bool errorsOnly = false;
            if (arguments.TryGetProperty("errorsOnly", out var errorsEl))
                errorsOnly = errorsEl.GetBoolean();

            _sendActivity($"Getting diagnostics{(specificPath != null ? $": {specificPath}" : "")}");

            var sb = new StringBuilder();
            sb.AppendLine("# Compilation Diagnostics");
            sb.AppendLine();

            try
            {
                // Get C# files to analyze
                var csFiles = _workspaceAnalysis.AllFiles
                    .Where(f => f.Extension == ".cs")
                    .ToList();

                if (specificPath != null)
                {
                    csFiles = csFiles.Where(f =>
                        f.RelativePath.Equals(specificPath, StringComparison.OrdinalIgnoreCase) ||
                        f.FileName.Equals(specificPath, StringComparison.OrdinalIgnoreCase)).ToList();

                    if (csFiles.Count == 0)
                        return $"Error: File not found: {specificPath}";
                }

                // MEMORY OPTIMIZATION: Limit files to prevent memory explosion
                const int MaxFilesForDiagnostics = 50;
                bool truncated = csFiles.Count > MaxFilesForDiagnostics;
                if (truncated)
                {
                    sb.AppendLine($"⚠️ **Note:** Analyzing first {MaxFilesForDiagnostics} of {csFiles.Count} files to prevent memory issues.");
                    sb.AppendLine();
                    csFiles = csFiles.Take(MaxFilesForDiagnostics).ToList();
                }

                // Parse all files into syntax trees
                var syntaxTrees = new List<SyntaxTree>();
                foreach (var file in csFiles)
                {
                    try
                    {
                        var content = File.ReadAllText(file.FilePath);
                        var tree = CSharpSyntaxTree.ParseText(content, path: file.RelativePath);
                        syntaxTrees.Add(tree);
                    }
                    catch (Exception ex)
                    {
                        sb.AppendLine($"**Parse error in `{file.RelativePath}`:** {ex.Message}");
                    }
                }

                // Create compilation with common references
                var references = new List<MetadataReference>
                {
                    MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(Console).Assembly.Location),
                    MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
                };

                // Try to add System.Runtime
                var runtimePath = Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Runtime.dll");
                if (File.Exists(runtimePath))
                    references.Add(MetadataReference.CreateFromFile(runtimePath));

                var compilation = CSharpCompilation.Create(
                    "DiagnosticsCheck",
                    syntaxTrees,
                    references,
                    new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

                // Get diagnostics
                var diagnostics = compilation.GetDiagnostics()
                    .Where(d => d.Location.IsInSource)
                    .Where(d => !errorsOnly || d.Severity == DiagnosticSeverity.Error)
                    .OrderByDescending(d => d.Severity)
                    .ThenBy(d => d.Location.SourceTree?.FilePath)
                    .ThenBy(d => d.Location.GetLineSpan().StartLinePosition.Line)
                    .ToList();

                var errors = diagnostics.Count(d => d.Severity == DiagnosticSeverity.Error);
                var warnings = diagnostics.Count(d => d.Severity == DiagnosticSeverity.Warning);

                sb.AppendLine($"**Files analyzed:** {csFiles.Count}");
                sb.AppendLine($"**Errors:** {errors}");
                if (!errorsOnly)
                    sb.AppendLine($"**Warnings:** {warnings}");
                sb.AppendLine();

                if (diagnostics.Count == 0)
                {
                    sb.AppendLine("✓ No issues found!");
                }
                else
                {
                    // Group by file
                    var byFile = diagnostics.GroupBy(d => d.Location.SourceTree?.FilePath ?? "Unknown");

                    foreach (var fileGroup in byFile)
                    {
                        sb.AppendLine($"## `{fileGroup.Key}`");
                        sb.AppendLine();

                        foreach (var diag in fileGroup.Take(20))
                        {
                            var lineSpan = diag.Location.GetLineSpan();
                            var line = lineSpan.StartLinePosition.Line + 1;
                            var severity = diag.Severity == DiagnosticSeverity.Error ? "❌" : "⚠️";
                            sb.AppendLine($"- {severity} **Line {line}:** [{diag.Id}] {diag.GetMessage()}");
                        }

                        if (fileGroup.Count() > 20)
                            sb.AppendLine($"- ... and {fileGroup.Count() - 20} more issues");

                        sb.AppendLine();
                    }
                }

                // Note about limitations
                sb.AppendLine("---");
                sb.AppendLine("*Note: This analysis uses basic references. Some errors about missing types may be false positives if they reference NuGet packages or project-specific assemblies.*");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error running diagnostics: {ex.Message}";
            }
            finally
            {
                // Force GC to release Roslyn compilation memory immediately
                GC.Collect(2, GCCollectionMode.Aggressive, blocking: false);
            }
        }

        /// <summary>
        /// Runs dotnet build on the project and returns real compilation results.
        /// </summary>
        public string Build(JsonElement arguments)
        {
            string? configuration = "Debug";
            if (arguments.TryGetProperty("configuration", out var configEl))
                configuration = configEl.GetString() ?? "Debug";

            bool verboseOutput = false;
            if (arguments.TryGetProperty("verbose", out var verboseEl))
                verboseOutput = verboseEl.GetBoolean();

            _sendActivity($"Building ({configuration})...");

            var sb = new StringBuilder();
            sb.AppendLine("# Build Results");
            sb.AppendLine();

            try
            {
                // Find project or solution file
                var (projectFile, projectType) = FindProjectFile();

                if (projectFile == null)
                {
                    return "Error: No .csproj or .sln file found in the workspace directories.";
                }

                sb.AppendLine($"**Project:** `{Path.GetFileName(projectFile)}`");
                sb.AppendLine($"**Configuration:** {configuration}");
                sb.AppendLine();

                // Run dotnet build
                var startInfo = new ProcessStartInfo
                {
                    FileName = "dotnet",
                    Arguments = $"build \"{projectFile}\" --configuration {configuration} --no-incremental",
                    WorkingDirectory = Path.GetDirectoryName(projectFile),
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = startInfo };
                var output = new StringBuilder();
                var errorOutput = new StringBuilder();

                process.OutputDataReceived += (s, e) => { if (e.Data != null) output.AppendLine(e.Data); };
                process.ErrorDataReceived += (s, e) => { if (e.Data != null) errorOutput.AppendLine(e.Data); };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                // Wait with timeout (2 minutes)
                bool completed = process.WaitForExit(120000);

                if (!completed)
                {
                    process.Kill();
                    return "Error: Build timed out after 2 minutes.";
                }

                var fullOutput = output.ToString() + errorOutput.ToString();

                // Parse build results
                var (errors, warnings) = ParseBuildOutput(fullOutput);

                if (process.ExitCode == 0)
                {
                    sb.AppendLine("## ✅ Build Succeeded");
                }
                else
                {
                    sb.AppendLine("## ❌ Build Failed");
                }
                sb.AppendLine();

                sb.AppendLine($"**Errors:** {errors.Count}");
                sb.AppendLine($"**Warnings:** {warnings.Count}");
                sb.AppendLine();

                if (errors.Count > 0)
                {
                    sb.AppendLine("## Errors");
                    foreach (var error in errors.Take(50))
                    {
                        sb.AppendLine($"- ❌ {error}");
                    }
                    if (errors.Count > 50)
                        sb.AppendLine($"- ... and {errors.Count - 50} more errors");
                    sb.AppendLine();
                }

                if (warnings.Count > 0)
                {
                    sb.AppendLine("## Warnings");
                    foreach (var warning in warnings.Take(30))
                    {
                        sb.AppendLine($"- ⚠️ {warning}");
                    }
                    if (warnings.Count > 30)
                        sb.AppendLine($"- ... and {warnings.Count - 30} more warnings");
                    sb.AppendLine();
                }

                if (verboseOutput)
                {
                    sb.AppendLine("## Full Output");
                    sb.AppendLine("```");
                    sb.AppendLine(fullOutput.Length > 10000 ? fullOutput.Substring(0, 10000) + "\n... (truncated)" : fullOutput);
                    sb.AppendLine("```");
                }

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error running build: {ex.Message}\n\nMake sure `dotnet` is installed and available in PATH.";
            }
        }

        private (string? path, string type) FindProjectFile()
        {
            // First look for .sln files
            foreach (var dir in _inputDirectories)
            {
                var slnFiles = Directory.GetFiles(dir, "*.sln", SearchOption.TopDirectoryOnly);
                if (slnFiles.Length > 0)
                    return (slnFiles[0], "solution");
            }

            // Then look for .csproj files
            foreach (var dir in _inputDirectories)
            {
                var csprojFiles = Directory.GetFiles(dir, "*.csproj", SearchOption.TopDirectoryOnly);
                if (csprojFiles.Length > 0)
                    return (csprojFiles[0], "project");
            }

            // Search one level deep
            foreach (var dir in _inputDirectories)
            {
                var csprojFiles = Directory.GetFiles(dir, "*.csproj", SearchOption.AllDirectories);
                if (csprojFiles.Length > 0)
                    return (csprojFiles[0], "project");
            }

            return (null, "none");
        }

        private (List<string> errors, List<string> warnings) ParseBuildOutput(string output)
        {
            var errors = new List<string>();
            var warnings = new List<string>();

            // MSBuild/dotnet build output patterns:
            // file.cs(line,col): error CS1234: message
            // file.cs(line,col): warning CS1234: message
            var errorPattern = new Regex(@"^(.+?)\((\d+),(\d+)\):\s*error\s+(\w+):\s*(.+)$", RegexOptions.Multiline);
            var warningPattern = new Regex(@"^(.+?)\((\d+),(\d+)\):\s*warning\s+(\w+):\s*(.+)$", RegexOptions.Multiline);

            foreach (Match match in errorPattern.Matches(output))
            {
                var file = Path.GetFileName(match.Groups[1].Value);
                var line = match.Groups[2].Value;
                var code = match.Groups[4].Value;
                var message = match.Groups[5].Value;
                errors.Add($"`{file}:{line}` [{code}] {message}");
            }

            foreach (Match match in warningPattern.Matches(output))
            {
                var file = Path.GetFileName(match.Groups[1].Value);
                var line = match.Groups[2].Value;
                var code = match.Groups[4].Value;
                var message = match.Groups[5].Value;
                warnings.Add($"`{file}:{line}` [{code}] {message}");
            }

            // Also catch general error lines (like MSBuild errors)
            var generalErrorPattern = new Regex(@"^\s*error\s+(\w+):\s*(.+)$", RegexOptions.Multiline | RegexOptions.IgnoreCase);
            foreach (Match match in generalErrorPattern.Matches(output))
            {
                var code = match.Groups[1].Value;
                var message = match.Groups[2].Value;
                var errorText = $"[{code}] {message}";
                if (!errors.Any(e => e.Contains(message)))
                    errors.Add(errorText);
            }

            return (errors, warnings);
        }
    }
}
