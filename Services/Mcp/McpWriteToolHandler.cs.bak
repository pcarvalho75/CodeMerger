using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using CodeMerger.Models;

namespace CodeMerger.Services.Mcp
{
    /// <summary>
    /// Handles file write MCP tools.
    /// </summary>
    public class McpWriteToolHandler
    {
        private readonly WorkspaceAnalysis _workspaceAnalysis;
        private readonly RefactoringService _refactoringService;
        private readonly List<string> _inputDirectories;
        private readonly Action<string> _updateFileIndex;
        private readonly Action<string> _sendActivity;
        private readonly Action<string> _log;

        public McpWriteToolHandler(
            WorkspaceAnalysis workspaceAnalysis,
            RefactoringService refactoringService,
            List<string> inputDirectories,
            Action<string> updateFileIndex,
            Action<string> sendActivity,
            Action<string> log)
        {
            _workspaceAnalysis = workspaceAnalysis;
            _refactoringService = refactoringService;
            _inputDirectories = inputDirectories;
            _updateFileIndex = updateFileIndex;
            _sendActivity = sendActivity;
            _log = log;
        }

        /// <summary>
        /// Finds a file by path with disambiguation when multiple files match.
        /// Returns (file, null) on success, (null, errorMessage) on failure.
        /// </summary>
        private (FileAnalysis? file, string? error) FindFile(string path)
        {
            var normalizedPath = path.Replace('\\', '/');

            var matches = _workspaceAnalysis.AllFiles.Where(f =>
                f.RelativePath.Equals(path, StringComparison.OrdinalIgnoreCase) ||
                f.RelativePath.Replace('\\', '/').Equals(normalizedPath, StringComparison.OrdinalIgnoreCase) ||
                f.FileName.Equals(path, StringComparison.OrdinalIgnoreCase)).ToList();

            if (matches.Count == 0)
            {
                return (null, $"Error: File not found: {path}");
            }

            if (matches.Count > 1)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"Error: Ambiguous path '{path}' matches {matches.Count} files:");
                sb.AppendLine();
                foreach (var m in matches)
                {
                    var rootName = !string.IsNullOrEmpty(m.RootDirectory)
                        ? Path.GetFileName(m.RootDirectory.TrimEnd('\\', '/'))
                        : "unknown";
                    sb.AppendLine($"- `{m.RelativePath}` in root **{rootName}** (`{m.RootDirectory}`)");
                }
                sb.AppendLine();
                sb.AppendLine("Please use the full relative path to disambiguate.");
                return (null, sb.ToString());
            }

            return (matches[0], null);
        }

        public string StrReplace(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("oldStr", out var oldStrEl))
                return "Error: 'oldStr' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var oldStr = oldStrEl.GetString() ?? "";
            var newStr = arguments.TryGetProperty("newStr", out var newStrEl) ? newStrEl.GetString() ?? "" : "";

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            _sendActivity($"StrReplace: {path}");

            var (file, findError) = FindFile(path);
            if (file == null)
            {
                return findError!;
            }

            try
            {
                var content = File.ReadAllText(file.FilePath);
                var fileLineEnding = DetectLineEnding(content);

                // Try matching with progressively more lenient normalization
                var matchResult = TryFindMatch(content, oldStr, fileLineEnding);

                if (!matchResult.Found)
                {
                    return BuildNotFoundDiagnostic(content, oldStr, file.RelativePath, matchResult);
                }

                if (matchResult.Count > 1)
                {
                    return $"Error: String appears {matchResult.Count} times in file. It must be unique (appear exactly once).\n\n" +
                           $"**Looking for:**\n```\n{oldStr}\n```\n\n" +
                           $"**Matched at lines:** {string.Join(", ", matchResult.LineNumbers)}";
                }

                if (createBackup && File.Exists(file.FilePath))
                {
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);
                }

                // Perform the replacement using the actual matched text
                var newContent = content.Substring(0, matchResult.StartIndex) +
                                 PrepareNewStr(newStr, fileLineEnding) +
                                 content.Substring(matchResult.EndIndex);

                File.WriteAllText(file.FilePath, newContent);

                var action = string.IsNullOrEmpty(newStr) ? "deleted" : "replaced";
                _log($"StrReplace: {path} - {action}");

                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine($"# String Replace Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Success - string {action}");
                if (createBackup)
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");
                if (matchResult.NormalizationUsed != NormalizationLevel.None)
                    sb.AppendLine($"**Note:** Matched using {matchResult.NormalizationUsed.ToString().ToLower()} normalization");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        private enum NormalizationLevel
        {
            None,           // Exact match (after line ending normalization)
            TrailingSpace,  // Trailing whitespace trimmed
            LeadingSpace,   // Leading whitespace normalized (tabsâ†”spaces)
            AllWhitespace   // All whitespace runs collapsed
        }

        private class MatchResult
        {
            public bool Found { get; set; }
            public int Count { get; set; }
            public int StartIndex { get; set; }
            public int EndIndex { get; set; }
            public List<int> LineNumbers { get; set; } = new();
            public NormalizationLevel NormalizationUsed { get; set; }
            public string? ClosestMatch { get; set; }
            public int ClosestMatchLine { get; set; }
            public double ClosestMatchScore { get; set; }
        }

        /// <summary>
        /// Tries to find the search string with progressively more lenient normalization.
        /// Returns the match position in the ORIGINAL content.
        /// </summary>
        private MatchResult TryFindMatch(string content, string searchStr, string fileLineEnding)
        {
            // Level 0: Just normalize line endings
            var result = TryMatchAtLevel(content, searchStr, NormalizationLevel.None);
            if (result.Found) return result;

            // Level 1: Trim trailing whitespace per line
            result = TryMatchAtLevel(content, searchStr, NormalizationLevel.TrailingSpace);
            if (result.Found) return result;

            // Level 2: Normalize leading whitespace (tabs to spaces based on file's indentation style)
            result = TryMatchAtLevel(content, searchStr, NormalizationLevel.LeadingSpace);
            if (result.Found) return result;

            // Level 3: Collapse all whitespace runs (last resort)
            result = TryMatchAtLevel(content, searchStr, NormalizationLevel.AllWhitespace);
            if (result.Found) return result;

            // No match found - try to find closest match for diagnostics
            FindClosestMatch(content, searchStr, result);

            return result;
        }

        private MatchResult TryMatchAtLevel(string content, string searchStr, NormalizationLevel level)
        {
            var result = new MatchResult { NormalizationUsed = level };

            // Normalize both content and search string at this level
            var normalizedContent = NormalizeAtLevel(content, level);
            var normalizedSearch = NormalizeAtLevel(searchStr, level);

            // Find all occurrences in normalized content
            var matches = new List<int>();
            var index = 0;
            while ((index = normalizedContent.IndexOf(normalizedSearch, index, StringComparison.Ordinal)) != -1)
            {
                matches.Add(index);
                index += normalizedSearch.Length;
            }

            result.Count = matches.Count;

            if (matches.Count == 0)
            {
                result.Found = false;
                return result;
            }

            result.Found = true;

            // Map normalized position back to original position
            var normalizedMatchStart = matches[0];
            var normalizedMatchEnd = normalizedMatchStart + normalizedSearch.Length;

            // Find the corresponding position in the original content
            var (originalStart, originalEnd) = MapNormalizedToOriginal(content, normalizedContent, normalizedMatchStart, normalizedMatchEnd, level);

            result.StartIndex = originalStart;
            result.EndIndex = originalEnd;

            // Get line numbers for all matches
            foreach (var matchPos in matches)
            {
                var lineNum = normalizedContent.Substring(0, matchPos).Count(c => c == '\n') + 1;
                result.LineNumbers.Add(lineNum);
            }

            return result;
        }

        /// <summary>
        /// Maps a position in normalized content back to the original content.
        /// </summary>
        private (int start, int end) MapNormalizedToOriginal(string original, string normalized, int normStart, int normEnd, NormalizationLevel level)
        {
            if (level == NormalizationLevel.None)
            {
                return (normStart, normEnd);
            }

            // For simple trailing whitespace trimming, we can map line by line
            var originalLines = original.Split('\n');
            var normalizedLines = normalized.Split('\n');

            int originalPos = 0;
            int normalizedPos = 0;
            int resultStart = -1;
            int resultEnd = -1;

            for (int i = 0; i < normalizedLines.Length; i++)
            {
                var normLineLen = normalizedLines[i].Length + 1; // +1 for \n
                var origLineLen = originalLines[i].Length + 1;

                // Check if match start is in this line
                if (resultStart == -1 && normalizedPos + normLineLen > normStart)
                {
                    var offsetInLine = normStart - normalizedPos;
                    resultStart = originalPos + MapOffsetInLine(originalLines[i], normalizedLines[i], offsetInLine, level);
                }

                // Check if match end is in this line
                if (resultEnd == -1 && normalizedPos + normLineLen >= normEnd)
                {
                    var offsetInLine = normEnd - normalizedPos;
                    resultEnd = originalPos + MapOffsetInLine(originalLines[i], normalizedLines[i], offsetInLine, level);
                    break;
                }

                normalizedPos += normLineLen;
                originalPos += origLineLen;
            }

            // Fallback if mapping failed
            if (resultStart == -1) resultStart = 0;
            if (resultEnd == -1) resultEnd = original.Length;

            return (resultStart, resultEnd);
        }

        /// <summary>
        /// Maps an offset within a normalized line back to the original line.
        /// </summary>
        private int MapOffsetInLine(string originalLine, string normalizedLine, int normalizedOffset, NormalizationLevel level)
        {
            if (normalizedOffset >= normalizedLine.Length)
                return originalLine.Length;

            if (level == NormalizationLevel.TrailingSpace)
            {
                // Trailing space normalization doesn't affect positions within the content
                return Math.Min(normalizedOffset, originalLine.Length);
            }

            if (level == NormalizationLevel.LeadingSpace || level == NormalizationLevel.AllWhitespace)
            {
                // Walk through both strings character by character
                int origIdx = 0;
                int normIdx = 0;

                while (normIdx < normalizedOffset && origIdx < originalLine.Length)
                {
                    // Skip through whitespace that may have been normalized
                    if (level == NormalizationLevel.AllWhitespace && char.IsWhiteSpace(normalizedLine[normIdx]))
                    {
                        // In all-whitespace mode, skip all whitespace in original
                        while (origIdx < originalLine.Length && char.IsWhiteSpace(originalLine[origIdx]))
                            origIdx++;
                        // Skip the single space in normalized
                        normIdx++;
                    }
                    else
                    {
                        origIdx++;
                        normIdx++;
                    }
                }

                return origIdx;
            }

            return normalizedOffset;
        }

        private string NormalizeAtLevel(string text, NormalizationLevel level)
        {
            // Always normalize line endings to \n for matching
            var result = text.Replace("\r\n", "\n").Replace("\r", "\n");

            switch (level)
            {
                case NormalizationLevel.None:
                    return result;

                case NormalizationLevel.TrailingSpace:
                    return TrimTrailingWhitespacePerLine(result);

                case NormalizationLevel.LeadingSpace:
                    result = TrimTrailingWhitespacePerLine(result);
                    result = NormalizeLeadingWhitespace(result);
                    return result;

                case NormalizationLevel.AllWhitespace:
                    result = TrimTrailingWhitespacePerLine(result);
                    result = CollapseWhitespaceRuns(result);
                    return result;

                default:
                    return result;
            }
        }

        /// <summary>
        /// Normalizes leading whitespace: converts tabs to 4 spaces.
        /// </summary>
        private string NormalizeLeadingWhitespace(string text)
        {
            var lines = text.Split('\n');
            for (int i = 0; i < lines.Length; i++)
            {
                var line = lines[i];
                int leadingEnd = 0;
                while (leadingEnd < line.Length && (line[leadingEnd] == ' ' || line[leadingEnd] == '\t'))
                    leadingEnd++;

                if (leadingEnd > 0)
                {
                    var leading = line.Substring(0, leadingEnd).Replace("\t", "    ");
                    lines[i] = leading + line.Substring(leadingEnd);
                }
            }
            return string.Join("\n", lines);
        }

        /// <summary>
        /// Collapses runs of whitespace (spaces/tabs) into single spaces.
        /// Preserves newlines.
        /// </summary>
        private string CollapseWhitespaceRuns(string text)
        {
            var sb = new StringBuilder(text.Length);
            bool lastWasSpace = false;

            foreach (var c in text)
            {
                if (c == '\n')
                {
                    sb.Append(c);
                    lastWasSpace = false;
                }
                else if (c == ' ' || c == '\t')
                {
                    if (!lastWasSpace)
                    {
                        sb.Append(' ');
                        lastWasSpace = true;
                    }
                }
                else
                {
                    sb.Append(c);
                    lastWasSpace = false;
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Prepares the new string for insertion, normalizing line endings to match the file.
        /// </summary>
        private string PrepareNewStr(string newStr, string fileLineEnding)
        {
            var result = newStr.Replace("\r\n", "\n").Replace("\r", "\n");
            if (fileLineEnding != "\n")
                result = result.Replace("\n", fileLineEnding);
            return result;
        }

        /// <summary>
        /// Finds the closest matching line for diagnostic purposes.
        /// </summary>
        private void FindClosestMatch(string content, string searchStr, MatchResult result)
        {
            var searchLines = searchStr.Split('\n');
            var firstSearchLine = searchLines.FirstOrDefault(l => l.Trim().Length > 5)?.Trim() ?? "";

            if (firstSearchLine.Length < 5) return;

            var contentLines = content.Split('\n');
            var bestScore = 0.0;
            var bestLine = "";
            var bestLineNum = 0;

            for (int i = 0; i < contentLines.Length; i++)
            {
                var line = contentLines[i].Trim();
                if (line.Length < 3) continue;

                var score = CalculateSimilarity(line, firstSearchLine);
                if (score > bestScore)
                {
                    bestScore = score;
                    bestLine = contentLines[i];
                    bestLineNum = i + 1;
                }
            }

            if (bestScore > 0.5)
            {
                result.ClosestMatch = bestLine;
                result.ClosestMatchLine = bestLineNum;
                result.ClosestMatchScore = bestScore;
            }
        }

        /// <summary>
        /// Calculates similarity between two strings (0.0 to 1.0).
        /// </summary>
        private double CalculateSimilarity(string a, string b)
        {
            if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return 0;

            // Simple containment check
            if (a.Contains(b) || b.Contains(a))
                return 0.9;

            // Check for common substring ratio
            var shorter = a.Length < b.Length ? a : b;
            var longer = a.Length < b.Length ? b : a;

            int commonChars = 0;
            foreach (var c in shorter)
            {
                if (longer.Contains(c))
                    commonChars++;
            }

            return (double)commonChars / longer.Length;
        }

        /// <summary>
        /// Builds a diagnostic message when the search string is not found.
        /// Shows whitespace details and closest match if found.
        /// </summary>
        private string BuildNotFoundDiagnostic(string content, string oldStr, string filePath, MatchResult matchResult)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# Error: String not found in file");
            sb.AppendLine();
            sb.AppendLine($"**File:** `{filePath}`");
            sb.AppendLine();

            // Show what we were looking for with whitespace visualization
            var oldStrLines = oldStr.Split('\n');
            sb.AppendLine($"**Looking for ({oldStrLines.Length} lines, {oldStr.Length} chars):**");
            sb.AppendLine("```");
            foreach (var line in oldStrLines.Take(10))
            {
                sb.AppendLine(VisualizeWhitespace(line.TrimEnd('\r')));
            }
            if (oldStrLines.Length > 10)
                sb.AppendLine($"... ({oldStrLines.Length - 10} more lines)");
            sb.AppendLine("```");
            sb.AppendLine();

            // Show closest match if found
            if (matchResult.ClosestMatchScore > 0.5 && !string.IsNullOrEmpty(matchResult.ClosestMatch))
            {
                sb.AppendLine($"**Closest match found ({matchResult.ClosestMatchScore:P0} similar) at line {matchResult.ClosestMatchLine}:**");
                sb.AppendLine("```");
                sb.AppendLine(VisualizeWhitespace(matchResult.ClosestMatch.TrimEnd('\r', '\n')));
                sb.AppendLine("```");
                sb.AppendLine();
                sb.AppendLine("ðŸ’¡ **Tip:** Use `codemerger_get_lines` to see exact content around this line.");
            }
            else
            {
                // Try to find partial matches using the first non-empty line
                var firstLine = oldStrLines.FirstOrDefault(l => l.Trim().Length > 0)?.Trim() ?? "";
                if (firstLine.Length > 10)
                {
                    var contentLines = content.Split('\n');
                    var partialMatches = new List<(int lineNum, string line)>();

                    for (int i = 0; i < contentLines.Length; i++)
                    {
                        if (contentLines[i].Trim().Contains(firstLine.Substring(0, Math.Min(20, firstLine.Length))))
                        {
                            partialMatches.Add((i + 1, contentLines[i]));
                        }
                    }

                    if (partialMatches.Count > 0)
                    {
                        sb.AppendLine("**Possible matches found (similar content at these lines):**");
                        sb.AppendLine("```");
                        foreach (var (lineNum, line) in partialMatches.Take(5))
                        {
                            sb.AppendLine($"Line {lineNum}: {VisualizeWhitespace(line.TrimEnd('\r'))}");
                        }
                        sb.AppendLine("```");
                        sb.AppendLine();
                        sb.AppendLine("ðŸ’¡ **Tip:** Use `codemerger_get_lines` to see exact file content.");
                    }
                    else
                    {
                        sb.AppendLine("**No similar content found.** The code may have changed or the search text is incorrect.");
                    }
                }
            }

            sb.AppendLine();
            sb.AppendLine("**Whitespace legend:** `â†’` = tab, space = space");
            sb.AppendLine();
            sb.AppendLine("**Normalization tried:** Line endings â†’ Trailing whitespace â†’ Leading whitespace (tabsâ†”spaces) â†’ Collapsed whitespace");

            return sb.ToString();
        }

        /// <summary>
        /// Detects the line ending style used in the file content.
        /// </summary>
        private static string DetectLineEnding(string content)
        {
            // Check for Windows-style CRLF first
            if (content.Contains("\r\n"))
                return "\r\n";
            // Check for old Mac-style CR (rare)
            if (content.Contains("\r"))
                return "\r";
            // Default to Unix-style LF
            return "\n";
        }

        /// <summary>
        /// Normalizes the search string's line endings to match the file's line endings.
        /// </summary>
        private static string NormalizeLineEndings(string searchStr, string targetLineEnding)
        {
            // First normalize to LF, then convert to target
            var normalized = searchStr.Replace("\r\n", "\n").Replace("\r", "\n");
            if (targetLineEnding != "\n")
                normalized = normalized.Replace("\n", targetLineEnding);
            return normalized;
        }

        /// <summary>
        /// Trims trailing whitespace from each line while preserving line endings.
        /// </summary>
        private static string TrimTrailingWhitespacePerLine(string text)
        {
            var lines = text.Split('\n');
            for (int i = 0; i < lines.Length; i++)
            {
                // Remove trailing whitespace but preserve \r if present (will be before the split point)
                lines[i] = lines[i].TrimEnd(' ', '\t', '\r');
            }
            return string.Join("\n", lines);
        }

        /// <summary>
        /// Makes leading whitespace visible by showing tabs as â†’ and preserving spaces.
        /// </summary>
        private static string VisualizeWhitespace(string line)
        {
            if (string.IsNullOrEmpty(line)) return line;

            // Find the end of leading whitespace
            int i = 0;
            while (i < line.Length && (line[i] == ' ' || line[i] == '\t'))
                i++;

            if (i == 0) return line;

            // Visualize leading whitespace: tabs become â†’, spaces stay as spaces
            var leading = line.Substring(0, i).Replace("\t", "â†’");
            var rest = line.Substring(i);

            return leading + rest;
        }

        public string WriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Writing: {path}");

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            var result = _refactoringService.WriteFile(path, content, createBackup);
            _log($"WriteFile: {path} - {(result.Success ? "OK" : "FAILED")}");

            // Update index for this file in background (non-blocking)
            if (result.Success && !string.IsNullOrEmpty(result.FullPath))
                _updateFileIndex(result.FullPath);

            return result.ToMarkdown();
        }

        public string PreviewWriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Preview: {path}");

            var result = _refactoringService.PreviewWriteFile(path, content);
            _log($"PreviewWrite: {path}");

            return result.ToMarkdown();
        }

        public string DeleteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Deleting: {path}");

            var (file, findError) = FindFile(path);
            if (file == null)
                return findError!;

            try
            {
                // Create backup before deleting
                var backupPath = file.FilePath + ".bak";
                File.Copy(file.FilePath, backupPath, true);

                // Delete the file
                File.Delete(file.FilePath);

                _log($"DeleteFile: {path}");
                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine("# Delete File Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Deleted");
                sb.AppendLine($"**Backup:** `{backupPath}`");
                sb.AppendLine();
                sb.AppendLine("*Use `codemerger_undo` to restore this file if needed.*");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string Undo(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Undo: {path}");

            // Find the file or determine the full path
            var (file, findError) = FindFile(path);

            string fullPath;
            string relativePath;

            if (file != null)
            {
                fullPath = file.FilePath;
                relativePath = file.RelativePath;
            }
            else if (findError != null && findError.Contains("Ambiguous"))
            {
                // Multiple matches - return the ambiguity error
                return findError;
            }
            else
            {
                // File might have been deleted - try to find backup by constructing path
                if (_inputDirectories == null || _inputDirectories.Count == 0)
                    return $"Error: Cannot determine file location for: {path}";

                fullPath = Path.Combine(_inputDirectories[0], path.Replace('/', Path.DirectorySeparatorChar));
                relativePath = path;
            }

            var backupPath = fullPath + ".bak";

            if (!File.Exists(backupPath))
                return $"Error: No backup found for: {path}\n\nExpected backup at: `{backupPath}`";

            try
            {
                // Restore from backup
                File.Copy(backupPath, fullPath, true);
                File.Delete(backupPath);

                _log($"Undo: {path}");
                _updateFileIndex(fullPath);

                var sb = new StringBuilder();
                sb.AppendLine("# Undo Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{relativePath}`");
                sb.AppendLine($"**Status:** Restored from backup");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string MoveFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("oldPath", out var oldPathEl))
                return "Error: 'oldPath' parameter is required.";
            if (!arguments.TryGetProperty("newPath", out var newPathEl))
                return "Error: 'newPath' parameter is required.";

            var oldPath = oldPathEl.GetString() ?? "";
            var newPath = newPathEl.GetString() ?? "";
            var preview = true;
            if (arguments.TryGetProperty("preview", out var previewEl))
                preview = previewEl.GetBoolean();

            _sendActivity($"MoveFile: {oldPath} -> {newPath}");

            var (file, findError) = FindFile(oldPath);
            if (file == null)
                return findError!;

            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(preview ? "# Move File Preview" : "# Move File Result");
                sb.AppendLine();
                sb.AppendLine($"**From:** `{oldPath}`");
                sb.AppendLine($"**To:** `{newPath}`");
                sb.AppendLine();

                // Determine old and new namespaces from directory structure
                var oldNamespace = GetNamespaceFromPath(oldPath);
                var newNamespace = GetNamespaceFromPath(newPath);

                var affectedFiles = new List<string>();

                if (oldNamespace != newNamespace && !string.IsNullOrEmpty(oldNamespace))
                {
                    sb.AppendLine($"**Namespace change:** `{oldNamespace}` â†’ `{newNamespace}`");
                    sb.AppendLine();

                    // Find files that reference types from the moved file
                    var typesInFile = file.Types.Select(t => t.Name).ToList();

                    foreach (var otherFile in _workspaceAnalysis.AllFiles.Where(f => f.Extension == ".cs" && f.FilePath != file.FilePath))
                    {
                        var content = File.ReadAllText(otherFile.FilePath);
                        bool needsUpdate = false;

                        // Check if file uses any types from the moved file
                        foreach (var typeName in typesInFile)
                        {
                            if (System.Text.RegularExpressions.Regex.IsMatch(content, $@"\b{typeName}\b"))
                            {
                                needsUpdate = true;
                                break;
                            }
                        }

                        // Check if file has using statement for old namespace
                        if (content.Contains($"using {oldNamespace};"))
                            needsUpdate = true;

                        if (needsUpdate)
                            affectedFiles.Add(otherFile.RelativePath);
                    }

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine("## Files that may need using statement updates");
                        foreach (var af in affectedFiles.Take(20))
                            sb.AppendLine($"- `{af}`");
                        if (affectedFiles.Count > 20)
                            sb.AppendLine($"- ... and {affectedFiles.Count - 20} more");
                        sb.AppendLine();
                    }
                }

                if (!preview)
                {
                    // Determine full paths
                    var oldDir = Path.GetDirectoryName(file.FilePath) ?? "";
                    var baseDir = oldDir;

                    // Walk up to find the base directory that matches the relative path structure
                    var relativeDir = Path.GetDirectoryName(oldPath.Replace('/', Path.DirectorySeparatorChar)) ?? "";
                    if (!string.IsNullOrEmpty(relativeDir))
                    {
                        baseDir = file.FilePath.Substring(0, file.FilePath.Length - oldPath.Length);
                    }

                    var newFullPath = Path.Combine(baseDir, newPath.Replace('/', Path.DirectorySeparatorChar));
                    var newDir = Path.GetDirectoryName(newFullPath);

                    // Create backup
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);

                    // Ensure target directory exists
                    if (!string.IsNullOrEmpty(newDir) && !Directory.Exists(newDir))
                        Directory.CreateDirectory(newDir);

                    // Update namespace in the file if needed
                    if (oldNamespace != newNamespace && !string.IsNullOrEmpty(newNamespace))
                    {
                        var content = File.ReadAllText(file.FilePath);
                        if (!string.IsNullOrEmpty(oldNamespace))
                            content = content.Replace($"namespace {oldNamespace}", $"namespace {newNamespace}");
                        File.WriteAllText(file.FilePath, content);
                    }

                    // Move the file
                    File.Move(file.FilePath, newFullPath, true);

                    _log($"MoveFile: {oldPath} -> {newPath}");
                    _updateFileIndex(file.FilePath);
                    _updateFileIndex(newFullPath);

                    sb.AppendLine("**Status:** Moved successfully");
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine();
                        sb.AppendLine("*Note: You may need to update using statements in the affected files listed above.*");
                    }
                }
                else
                {
                    sb.AppendLine("*This is a preview. Run with `preview: false` to apply the move.*");
                }

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        private string GetNamespaceFromPath(string relativePath)
        {
            var dir = Path.GetDirectoryName(relativePath);
            if (string.IsNullOrEmpty(dir))
                return string.Empty;

            // Convert path separators to dots and clean up
            return dir.Replace('/', '.').Replace('\\', '.').Trim('.');
        }
    }
}
