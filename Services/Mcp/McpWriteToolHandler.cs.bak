using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using CodeMerger.Models;

namespace CodeMerger.Services.Mcp
{
    /// <summary>
    /// Handles file write MCP tools.
    /// Fixed: Simplified StrReplace to avoid position mapping bugs.
    /// </summary>
    public class McpWriteToolHandler
    {
        private readonly WorkspaceAnalysis _workspaceAnalysis;
        private readonly RefactoringService _refactoringService;
        private readonly FilePathResolver _pathResolver;
        private readonly List<string> _inputDirectories;
        private readonly Action<string> _updateFileIndex;
        private readonly Action<string> _sendActivity;
        private readonly Action<string> _log;

        public McpWriteToolHandler(
            WorkspaceAnalysis workspaceAnalysis,
            RefactoringService refactoringService,
            List<string> inputDirectories,
            Action<string> updateFileIndex,
            Action<string> sendActivity,
            Action<string> log)
        {
            _workspaceAnalysis = workspaceAnalysis;
            _refactoringService = refactoringService;
            _pathResolver = new FilePathResolver(workspaceAnalysis, inputDirectories);
            _inputDirectories = inputDirectories;
            _updateFileIndex = updateFileIndex;
            _sendActivity = sendActivity;
            _log = log;
        }

        public string StrReplace(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("oldStr", out var oldStrEl))
                return "Error: 'oldStr' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var oldStr = oldStrEl.GetString() ?? "";
            var newStr = arguments.TryGetProperty("newStr", out var newStrEl) ? newStrEl.GetString() ?? "" : "";

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            var normalizeIndent = false;
            if (arguments.TryGetProperty("normalizeIndent", out var normalizeEl))
                normalizeIndent = normalizeEl.GetBoolean();

            _sendActivity($"StrReplace: {path}");

            var (file, findError) = _pathResolver.FindFile(path);
            if (file == null)
            {
                return findError!;
            }

            try
            {
                var content = File.ReadAllText(file.FilePath);

                // Normalize line endings in search string to match file
                var searchStr = oldStr;
                var replaceStr = newStr;

                // Detect file's line ending style
                string fileLineEnding = "\n";
                if (content.Contains("\r\n"))
                    fileLineEnding = "\r\n";
                else if (content.Contains("\r"))
                    fileLineEnding = "\r";

                // Normalize search string line endings to match file
                searchStr = searchStr.Replace("\r\n", "\n").Replace("\r", "\n");
                if (fileLineEnding != "\n")
                    searchStr = searchStr.Replace("\n", fileLineEnding);

                // Normalize replacement string line endings to match file
                replaceStr = replaceStr.Replace("\r\n", "\n").Replace("\r", "\n");
                if (fileLineEnding != "\n")
                    replaceStr = replaceStr.Replace("\n", fileLineEnding);

                int index;
                string matchedOriginal = "";

                if (normalizeIndent)
                {
                    // Find match with normalized indentation
                    var result = FindWithNormalizedIndent(content, searchStr, fileLineEnding);
                    index = result.index;
                    matchedOriginal = result.matchedText;

                    // Adapt replacement indentation to match original
                    if (index != -1 && !string.IsNullOrEmpty(matchedOriginal))
                    {
                        replaceStr = AdaptIndentation(replaceStr, matchedOriginal, fileLineEnding);
                    }
                }
                else
                {
                    // Find exact match
                    index = content.IndexOf(searchStr, StringComparison.Ordinal);
                    if (index != -1)
                        matchedOriginal = searchStr;
                }

                if (index == -1)
                {
                    // Not found - provide diagnostics
                    return BuildNotFoundError(content, oldStr, file.RelativePath, normalizeIndent);
                }

                // Check for multiple matches
                int matchLength = matchedOriginal.Length;
                int secondIndex;
                if (normalizeIndent)
                {
                    var secondResult = FindWithNormalizedIndent(content, searchStr, fileLineEnding, index + matchLength);
                    secondIndex = secondResult.index;
                }
                else
                {
                    secondIndex = content.IndexOf(searchStr, index + 1, StringComparison.Ordinal);
                }

                if (secondIndex != -1)
                {
                    return $"Error: String appears multiple times in file. It must be unique (appear exactly once).\n\n" +
                           $"ðŸ’¡ **Tip:** Include more surrounding context to make the match unique.";
                }

                // Create backup
                if (createBackup && File.Exists(file.FilePath))
                {
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);
                }

                // Perform the replacement
                var newContent = content.Substring(0, index) + replaceStr + content.Substring(index + matchLength);

                File.WriteAllText(file.FilePath, newContent);

                var action = string.IsNullOrEmpty(newStr) ? "deleted" : "replaced";
                _log($"StrReplace: {path} - {action}{(normalizeIndent ? " (indent-normalized)" : "")}");

                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine($"# String Replace Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Success - string {action}");
                if (createBackup)
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        /// <summary>
        /// Find a match with normalized indentation (ignores leading whitespace differences).
        /// Returns the index in the original content and the actual matched text.
        /// </summary>
        private (int index, string matchedText) FindWithNormalizedIndent(string content, string searchStr, string lineEnding, int startIndex = 0)
        {
            var searchLines = searchStr.Split(new[] { lineEnding }, StringSplitOptions.None);
            var contentLines = content.Split(new[] { lineEnding }, StringSplitOptions.None);

            // Normalize search lines (trim leading whitespace for comparison)
            var normalizedSearch = searchLines.Select(l => l.TrimStart()).ToArray();

            // Find first non-empty search line for initial matching
            int firstNonEmptyIdx = Array.FindIndex(normalizedSearch, l => !string.IsNullOrWhiteSpace(l));
            if (firstNonEmptyIdx == -1)
                return (-1, "");

            string firstSearchLine = normalizedSearch[firstNonEmptyIdx];

            // Calculate starting line index from character position
            int startLineIdx = 0;
            if (startIndex > 0)
            {
                int charCount = 0;
                for (int i = 0; i < contentLines.Length; i++)
                {
                    charCount += contentLines[i].Length + lineEnding.Length;
                    if (charCount > startIndex)
                    {
                        startLineIdx = i;
                        break;
                    }
                }
            }

            // Search through content lines
            for (int i = startLineIdx; i <= contentLines.Length - searchLines.Length; i++)
            {
                // Check if first non-empty line matches
                if (!contentLines[i + firstNonEmptyIdx].TrimStart().Equals(firstSearchLine, StringComparison.Ordinal))
                    continue;

                // Check all lines match (with normalized whitespace)
                bool allMatch = true;
                for (int j = 0; j < searchLines.Length; j++)
                {
                    var contentTrimmed = contentLines[i + j].TrimStart();
                    var searchTrimmed = normalizedSearch[j];

                    if (!contentTrimmed.Equals(searchTrimmed, StringComparison.Ordinal))
                    {
                        allMatch = false;
                        break;
                    }
                }

                if (allMatch)
                {
                    // Calculate character position of match start
                    int charPos = 0;
                    for (int k = 0; k < i; k++)
                        charPos += contentLines[k].Length + lineEnding.Length;

                    // Build the matched text from original content
                    var matchedLines = contentLines.Skip(i).Take(searchLines.Length);
                    var matchedText = string.Join(lineEnding, matchedLines);

                    return (charPos, matchedText);
                }
            }

            return (-1, "");
        }

        /// <summary>
        /// Adapt the replacement string's indentation to match the original matched text.
        /// </summary>
        private string AdaptIndentation(string replacement, string originalMatch, string lineEnding)
        {
            var replaceLines = replacement.Split(new[] { lineEnding }, StringSplitOptions.None);
            var originalLines = originalMatch.Split(new[] { lineEnding }, StringSplitOptions.None);

            if (replaceLines.Length == 0 || originalLines.Length == 0)
                return replacement;

            // Detect indentation style from original (first non-empty line)
            string baseIndent = "";
            foreach (var line in originalLines)
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    int contentStart = 0;
                    while (contentStart < line.Length && char.IsWhiteSpace(line[contentStart]))
                        contentStart++;
                    baseIndent = line.Substring(0, contentStart);
                    break;
                }
            }

            // Detect the indent unit from original (difference between indentation levels)
            string indentUnit = "    "; // default to 4 spaces
            string? prevIndent = null;
            foreach (var line in originalLines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                
                int contentStart = 0;
                while (contentStart < line.Length && char.IsWhiteSpace(line[contentStart]))
                    contentStart++;
                var currentIndent = line.Substring(0, contentStart);
                
                if (prevIndent != null && currentIndent.Length > prevIndent.Length)
                {
                    indentUnit = currentIndent.Substring(prevIndent.Length);
                    break;
                }
                prevIndent = currentIndent;
            }

            // Calculate minimum indent in replacement (to preserve relative indentation)
            int minReplaceIndent = int.MaxValue;
            foreach (var line in replaceLines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                int indent = 0;
                while (indent < line.Length && char.IsWhiteSpace(line[indent]))
                    indent++;
                minReplaceIndent = Math.Min(minReplaceIndent, indent);
            }
            if (minReplaceIndent == int.MaxValue) minReplaceIndent = 0;

            // Apply indentation to replacement lines
            var result = new StringBuilder();
            for (int i = 0; i < replaceLines.Length; i++)
            {
                if (i > 0) result.Append(lineEnding);

                var line = replaceLines[i];
                if (string.IsNullOrWhiteSpace(line))
                {
                    result.Append(line);
                    continue;
                }

                // Calculate this line's relative indentation
                int lineIndent = 0;
                while (lineIndent < line.Length && char.IsWhiteSpace(line[lineIndent]))
                    lineIndent++;
                int relativeIndent = lineIndent - minReplaceIndent;

                // Build new indentation
                string newIndent = baseIndent;
                for (int j = 0; j < relativeIndent / 4; j++) // Assuming 4-space units in input
                    newIndent += indentUnit;

                result.Append(newIndent);
                result.Append(line.TrimStart());
            }

            return result.ToString();
        }

        private string BuildNotFoundError(string content, string searchStr, string filePath, bool normalizeIndent = false)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# Error: String not found in file");
            sb.AppendLine();
            sb.AppendLine($"**File:** `{filePath}`");
            sb.AppendLine();

            // Show what we were looking for
            var lines = searchStr.Split('\n');
            sb.AppendLine($"**Looking for ({lines.Length} lines):**");
            sb.AppendLine("```");
            foreach (var line in lines.Take(10))
            {
                sb.AppendLine(line.TrimEnd('\r'));
            }
            if (lines.Length > 10)
                sb.AppendLine($"... ({lines.Length - 10} more lines)");
            sb.AppendLine("```");
            sb.AppendLine();

            // Try to find first line in file for hints
            var firstLine = lines.FirstOrDefault(l => l.Trim().Length > 5)?.Trim();
            if (!string.IsNullOrEmpty(firstLine))
            {
                var contentLines = content.Split('\n');
                for (int i = 0; i < contentLines.Length; i++)
                {
                    if (contentLines[i].Contains(firstLine.Substring(0, Math.Min(20, firstLine.Length))))
                    {
                        sb.AppendLine($"**Possible match at line {i + 1}:**");
                        sb.AppendLine("```");
                        sb.AppendLine(contentLines[i].TrimEnd('\r'));
                        sb.AppendLine("```");
                        sb.AppendLine();
                        break;
                    }
                }
            }

            sb.AppendLine("ðŸ’¡ **Tips:**");
            sb.AppendLine("- Use `codemerger_get_lines` to see exact file content");
            sb.AppendLine("- Check for whitespace differences (tabs vs spaces)");
            if (!normalizeIndent)
                sb.AppendLine("- Try `normalizeIndent: true` to ignore leading whitespace differences");
            sb.AppendLine("- Copy the exact text from `get_lines` output");

            return sb.ToString();
        }

        public string WriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Writing: {path}");

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            var result = _refactoringService.WriteFile(path, content, createBackup);
            _log($"WriteFile: {path} - {(result.Success ? "OK" : "FAILED")}");

            // Update index for this file in background (non-blocking)
            if (result.Success && !string.IsNullOrEmpty(result.FullPath))
                _updateFileIndex(result.FullPath);

            return result.ToMarkdown();
        }

        public string PreviewWriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Preview: {path}");

            var result = _refactoringService.PreviewWriteFile(path, content);
            _log($"PreviewWrite: {path}");

            return result.ToMarkdown();
        }

        public string DeleteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Deleting: {path}");

            var (file, findError) = _pathResolver.FindFile(path);
            if (file == null)
                return findError!;

            try
            {
                // Create backup before deleting
                var backupPath = file.FilePath + ".bak";
                File.Copy(file.FilePath, backupPath, true);

                // Delete the file
                File.Delete(file.FilePath);

                _log($"DeleteFile: {path}");
                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine("# Delete File Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Deleted");
                sb.AppendLine($"**Backup:** `{backupPath}`");
                sb.AppendLine();
                sb.AppendLine("*Use `codemerger_undo` to restore this file if needed.*");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string Undo(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Undo: {path}");

            // Find the file or determine the full path
            var (file, findError) = _pathResolver.FindFile(path);

            string fullPath;
            string relativePath;

            if (file != null)
            {
                fullPath = file.FilePath;
                relativePath = file.RelativePath;
            }
            else if (findError != null && findError.Contains("Ambiguous"))
            {
                // Multiple matches - return the ambiguity error
                return findError;
            }
            else
            {
                // File might have been deleted - try to find backup by constructing path
                if (_inputDirectories == null || _inputDirectories.Count == 0)
                    return $"Error: Cannot determine file location for: {path}";

                fullPath = Path.Combine(_inputDirectories[0], path.Replace('/', Path.DirectorySeparatorChar));
                relativePath = path;
            }

            var backupPath = fullPath + ".bak";

            if (!File.Exists(backupPath))
                return $"Error: No backup found for: {path}\n\nExpected backup at: `{backupPath}`";

            try
            {
                // Restore from backup
                File.Copy(backupPath, fullPath, true);
                File.Delete(backupPath);

                _log($"Undo: {path}");
                _updateFileIndex(fullPath);

                var sb = new StringBuilder();
                sb.AppendLine("# Undo Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{relativePath}`");
                sb.AppendLine($"**Status:** Restored from backup");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string MoveFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("oldPath", out var oldPathEl))
                return "Error: 'oldPath' parameter is required.";
            if (!arguments.TryGetProperty("newPath", out var newPathEl))
                return "Error: 'newPath' parameter is required.";

            var oldPath = oldPathEl.GetString() ?? "";
            var newPath = newPathEl.GetString() ?? "";
            var preview = true;
            if (arguments.TryGetProperty("preview", out var previewEl))
                preview = previewEl.GetBoolean();

            _sendActivity($"MoveFile: {oldPath} -> {newPath}");

            var (file, findError) = FindFile(oldPath);
            if (file == null)
                return findError!;

            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(preview ? "# Move File Preview" : "# Move File Result");
                sb.AppendLine();
                sb.AppendLine($"**From:** `{oldPath}`");
                sb.AppendLine($"**To:** `{newPath}`");
                sb.AppendLine();

                // Determine old and new namespaces from directory structure
                var oldNamespace = GetNamespaceFromPath(oldPath);
                var newNamespace = GetNamespaceFromPath(newPath);

                var affectedFiles = new List<string>();

                if (oldNamespace != newNamespace && !string.IsNullOrEmpty(oldNamespace))
                {
                    sb.AppendLine($"**Namespace change:** `{oldNamespace}` â†’ `{newNamespace}`");
                    sb.AppendLine();

                    // Find files that reference types from the moved file
                    var typesInFile = file.Types.Select(t => t.Name).ToList();

                    foreach (var otherFile in _workspaceAnalysis.AllFiles.Where(f => f.Extension == ".cs" && f.FilePath != file.FilePath))
                    {
                        var content = File.ReadAllText(otherFile.FilePath);
                        bool needsUpdate = false;

                        // Check if file uses any types from the moved file
                        foreach (var typeName in typesInFile)
                        {
                            if (System.Text.RegularExpressions.Regex.IsMatch(content, $@"\b{typeName}\b"))
                            {
                                needsUpdate = true;
                                break;
                            }
                        }

                        // Check if file has using statement for old namespace
                        if (content.Contains($"using {oldNamespace};"))
                            needsUpdate = true;

                        if (needsUpdate)
                            affectedFiles.Add(otherFile.RelativePath);
                    }

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine("## Files that may need using statement updates");
                        foreach (var af in affectedFiles.Take(20))
                            sb.AppendLine($"- `{af}`");
                        if (affectedFiles.Count > 20)
                            sb.AppendLine($"- ... and {affectedFiles.Count - 20} more");
                        sb.AppendLine();
                    }
                }

                if (!preview)
                {
                    // Determine full paths
                    var oldDir = Path.GetDirectoryName(file.FilePath) ?? "";
                    var baseDir = oldDir;

                    // Walk up to find the base directory that matches the relative path structure
                    var relativeDir = Path.GetDirectoryName(oldPath.Replace('/', Path.DirectorySeparatorChar)) ?? "";
                    if (!string.IsNullOrEmpty(relativeDir))
                    {
                        baseDir = file.FilePath.Substring(0, file.FilePath.Length - oldPath.Length);
                    }

                    var newFullPath = Path.Combine(baseDir, newPath.Replace('/', Path.DirectorySeparatorChar));
                    var newDir = Path.GetDirectoryName(newFullPath);

                    // Create backup
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);

                    // Ensure target directory exists
                    if (!string.IsNullOrEmpty(newDir) && !Directory.Exists(newDir))
                        Directory.CreateDirectory(newDir);

                    // Update namespace in the file if needed
                    if (oldNamespace != newNamespace && !string.IsNullOrEmpty(newNamespace))
                    {
                        var content = File.ReadAllText(file.FilePath);
                        if (!string.IsNullOrEmpty(oldNamespace))
                            content = content.Replace($"namespace {oldNamespace}", $"namespace {newNamespace}");
                        File.WriteAllText(file.FilePath, content);
                    }

                    // Move the file
                    File.Move(file.FilePath, newFullPath, true);

                    _log($"MoveFile: {oldPath} -> {newPath}");
                    _updateFileIndex(file.FilePath);
                    _updateFileIndex(newFullPath);

                    sb.AppendLine("**Status:** Moved successfully");
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine();
                        sb.AppendLine("*Note: You may need to update using statements in the affected files listed above.*");
                    }
                }
                else
                {
                    sb.AppendLine("*This is a preview. Run with `preview: false` to apply the move.*");
                }

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        private string GetNamespaceFromPath(string relativePath)
        {
            var dir = Path.GetDirectoryName(relativePath);
            if (string.IsNullOrEmpty(dir))
                return string.Empty;

            // Convert path separators to dots and clean up
            return dir.Replace('/', '.').Replace('\\', '.').Trim('.');
        }
    }
}
