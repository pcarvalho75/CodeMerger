using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using CodeMerger.Models;

namespace CodeMerger.Services.Mcp
{
    /// <summary>
    /// Handles file write MCP tools.
    /// </summary>
    public class McpWriteToolHandler
    {
        private readonly WorkspaceAnalysis _workspaceAnalysis;
        private readonly RefactoringService _refactoringService;
        private readonly List<string> _inputDirectories;
        private readonly Action<string> _updateFileIndex;
        private readonly Action<string> _sendActivity;
        private readonly Action<string> _log;

        public McpWriteToolHandler(
            WorkspaceAnalysis workspaceAnalysis,
            RefactoringService refactoringService,
            List<string> inputDirectories,
            Action<string> updateFileIndex,
            Action<string> sendActivity,
            Action<string> log)
        {
            _workspaceAnalysis = workspaceAnalysis;
            _refactoringService = refactoringService;
            _inputDirectories = inputDirectories;
            _updateFileIndex = updateFileIndex;
            _sendActivity = sendActivity;
            _log = log;
        }

        public string StrReplace(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("oldStr", out var oldStrEl))
                return "Error: 'oldStr' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var oldStr = oldStrEl.GetString() ?? "";
            var newStr = arguments.TryGetProperty("newStr", out var newStrEl) ? newStrEl.GetString() ?? "" : "";

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            _sendActivity($"StrReplace: {path}");

            var file = _workspaceAnalysis.AllFiles.FirstOrDefault(f =>
                f.RelativePath.Equals(path, StringComparison.OrdinalIgnoreCase) ||
                f.FileName.Equals(path, StringComparison.OrdinalIgnoreCase));

            if (file == null)
            {
                return $"Error: File not found: {path}";
            }

            try
            {
                var content = File.ReadAllText(file.FilePath);

                // Normalize line endings and trim trailing whitespace for matching
                var fileLineEnding = DetectLineEnding(content);
                var normalizedContent = TrimTrailingWhitespacePerLine(content);
                normalizedContent = NormalizeLineEndings(normalizedContent, "\n");

                var normalizedOldStr = TrimTrailingWhitespacePerLine(oldStr);
                normalizedOldStr = NormalizeLineEndings(normalizedOldStr, "\n");

                var normalizedNewStr = TrimTrailingWhitespacePerLine(newStr);
                normalizedNewStr = NormalizeLineEndings(normalizedNewStr, fileLineEnding);

                var count = 0;
                var index = 0;
                while ((index = normalizedContent.IndexOf(normalizedOldStr, index, StringComparison.Ordinal)) != -1)
                {
                    count++;
                    index += normalizedOldStr.Length;
                }

                if (count == 0)
                {
                    return BuildNotFoundDiagnostic(normalizedContent, normalizedOldStr, file.RelativePath);
                }

                if (count > 1)
                {
                    return $"Error: String appears {count} times in file. It must be unique (appear exactly once).\n\n**Looking for:**\n```\n{normalizedOldStr}\n```";
                }

                if (createBackup && File.Exists(file.FilePath))
                {
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);
                }

                // Replace in normalized content, then restore file's line endings
                var newContent = normalizedContent.Replace(normalizedOldStr, normalizedNewStr);
                newContent = NormalizeLineEndings(newContent, fileLineEnding);
                File.WriteAllText(file.FilePath, newContent);

                var action = string.IsNullOrEmpty(newStr) ? "deleted" : "replaced";
                _log($"StrReplace: {path} - {action}");

                // Update index for this file in background (non-blocking)
                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine($"# String Replace Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Success - string {action}");
                if (createBackup)
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        /// <summary>
        /// Builds a diagnostic message when the search string is not found.
        /// Shows whitespace details and tries to find partial matches.
        /// </summary>
        private string BuildNotFoundDiagnostic(string content, string oldStr, string filePath)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# Error: String not found in file");
            sb.AppendLine();
            sb.AppendLine($"**File:** `{filePath}`");
            sb.AppendLine();

            // Show what we were looking for with whitespace visualization
            var oldStrLines = oldStr.Split('\n');
            sb.AppendLine($"**Looking for ({oldStrLines.Length} lines, {oldStr.Length} chars):**");
            sb.AppendLine("```");
            foreach (var line in oldStrLines.Take(10))
            {
                sb.AppendLine(VisualizeWhitespace(line.TrimEnd('\r')));
            }
            if (oldStrLines.Length > 10)
                sb.AppendLine($"... ({oldStrLines.Length - 10} more lines)");
            sb.AppendLine("```");
            sb.AppendLine();

            // Try to find partial matches using the first non-empty line
            var firstLine = oldStrLines.FirstOrDefault(l => l.Trim().Length > 0)?.Trim() ?? "";
            if (firstLine.Length > 10)
            {
                var contentLines = content.Split('\n');
                var partialMatches = new System.Collections.Generic.List<(int lineNum, string line)>();

                for (int i = 0; i < contentLines.Length; i++)
                {
                    // Check if the trimmed content matches (ignoring whitespace differences)
                    if (contentLines[i].Trim().Contains(firstLine.Substring(0, Math.Min(20, firstLine.Length))))
                    {
                        partialMatches.Add((i + 1, contentLines[i]));
                    }
                }

                if (partialMatches.Count > 0)
                {
                    sb.AppendLine("**Possible matches found (similar content at these lines):**");
                    sb.AppendLine("```");
                    foreach (var (lineNum, line) in partialMatches.Take(5))
                    {
                        sb.AppendLine($"Line {lineNum}: {VisualizeWhitespace(line.TrimEnd('\r'))}");
                    }
                    sb.AppendLine("```");
                    sb.AppendLine();
                    sb.AppendLine("**Hint:** Whitespace mismatch? Use `codemerger_get_lines` to see exact file content.");
                }
                else
                {
                    sb.AppendLine("**No similar content found.** The code may have changed or the search text is incorrect.");
                }
            }

            // Show whitespace legend
            sb.AppendLine();
            sb.AppendLine("**Whitespace legend:** `→` = tab, space = space");

            return sb.ToString();
        }

        /// <summary>
        /// Detects the line ending style used in the file content.
        /// </summary>
        private static string DetectLineEnding(string content)
        {
            // Check for Windows-style CRLF first
            if (content.Contains("\r\n"))
                return "\r\n";
            // Check for old Mac-style CR (rare)
            if (content.Contains("\r"))
                return "\r";
            // Default to Unix-style LF
            return "\n";
        }

        /// <summary>
        /// Normalizes the search string's line endings to match the file's line endings.
        /// </summary>
        private static string NormalizeLineEndings(string searchStr, string targetLineEnding)
        {
            // First normalize to LF, then convert to target
            var normalized = searchStr.Replace("\r\n", "\n").Replace("\r", "\n");
            if (targetLineEnding != "\n")
                normalized = normalized.Replace("\n", targetLineEnding);
            return normalized;
        }

        /// <summary>
        /// Trims trailing whitespace from each line while preserving line endings.
        /// </summary>
        private static string TrimTrailingWhitespacePerLine(string text)
        {
            var lines = text.Split('\n');
            for (int i = 0; i < lines.Length; i++)
            {
                // Remove trailing whitespace but preserve \r if present (will be before the split point)
                lines[i] = lines[i].TrimEnd(' ', '\t', '\r');
            }
            return string.Join("\n", lines);
        }

        /// <summary>
        /// Makes leading whitespace visible by showing tabs as → and preserving spaces.
        /// </summary>
        private static string VisualizeWhitespace(string line)
        {
            if (string.IsNullOrEmpty(line)) return line;

            // Find the end of leading whitespace
            int i = 0;
            while (i < line.Length && (line[i] == ' ' || line[i] == '\t'))
                i++;

            if (i == 0) return line;

            // Visualize leading whitespace: tabs become →, spaces stay as spaces
            var leading = line.Substring(0, i).Replace("\t", "→");
            var rest = line.Substring(i);

            return leading + rest;
        }

        public string WriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Writing: {path}");

            var createBackup = true;
            if (arguments.TryGetProperty("createBackup", out var backupEl))
                createBackup = backupEl.GetBoolean();

            var result = _refactoringService.WriteFile(path, content, createBackup);
            _log($"WriteFile: {path} - {(result.Success ? "OK" : "FAILED")}");

            // Update index for this file in background (non-blocking)
            if (result.Success && !string.IsNullOrEmpty(result.FullPath))
                _updateFileIndex(result.FullPath);

            return result.ToMarkdown();
        }

        public string PreviewWriteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            if (!arguments.TryGetProperty("content", out var contentEl))
                return "Error: 'content' parameter is required.";

            var path = pathEl.GetString() ?? "";
            var content = contentEl.GetString() ?? "";

            _sendActivity($"Preview: {path}");

            var result = _refactoringService.PreviewWriteFile(path, content);
            _log($"PreviewWrite: {path}");

            return result.ToMarkdown();
        }

        public string DeleteFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Deleting: {path}");

            var file = _workspaceAnalysis.AllFiles.FirstOrDefault(f =>
                f.RelativePath.Equals(path, StringComparison.OrdinalIgnoreCase) ||
                f.FileName.Equals(path, StringComparison.OrdinalIgnoreCase));

            if (file == null)
                return $"Error: File not found: {path}";

            try
            {
                // Create backup before deleting
                var backupPath = file.FilePath + ".bak";
                File.Copy(file.FilePath, backupPath, true);

                // Delete the file
                File.Delete(file.FilePath);

                _log($"DeleteFile: {path}");
                _updateFileIndex(file.FilePath);

                var sb = new StringBuilder();
                sb.AppendLine("# Delete File Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{file.RelativePath}`");
                sb.AppendLine($"**Status:** Deleted");
                sb.AppendLine($"**Backup:** `{backupPath}`");
                sb.AppendLine();
                sb.AppendLine("*Use `codemerger_undo` to restore this file if needed.*");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string Undo(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("path", out var pathEl))
                return "Error: 'path' parameter is required.";

            var path = pathEl.GetString() ?? "";
            _sendActivity($"Undo: {path}");

            // Find the file or determine the full path
            var file = _workspaceAnalysis.AllFiles.FirstOrDefault(f =>
                f.RelativePath.Equals(path, StringComparison.OrdinalIgnoreCase) ||
                f.FileName.Equals(path, StringComparison.OrdinalIgnoreCase));

            string fullPath;
            string relativePath;

            if (file != null)
            {
                fullPath = file.FilePath;
                relativePath = file.RelativePath;
            }
            else
            {
                // File might have been deleted - try to find backup by constructing path
                var baseDir = _refactoringService.GetType()
                    .GetField("_inputDirectories", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                    ?.GetValue(_refactoringService) as List<string>;

                if (baseDir == null || baseDir.Count == 0)
                    return $"Error: Cannot determine file location for: {path}";

                fullPath = Path.Combine(baseDir[0], path.Replace('/', Path.DirectorySeparatorChar));
                relativePath = path;
            }

            var backupPath = fullPath + ".bak";

            if (!File.Exists(backupPath))
                return $"Error: No backup found for: {path}\n\nExpected backup at: `{backupPath}`";

            try
            {
                // Restore from backup
                File.Copy(backupPath, fullPath, true);
                File.Delete(backupPath);

                _log($"Undo: {path}");
                _updateFileIndex(fullPath);

                var sb = new StringBuilder();
                sb.AppendLine("# Undo Result");
                sb.AppendLine();
                sb.AppendLine($"**File:** `{relativePath}`");
                sb.AppendLine($"**Status:** Restored from backup");

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        public string MoveFile(JsonElement arguments)
        {
            if (!arguments.TryGetProperty("oldPath", out var oldPathEl))
                return "Error: 'oldPath' parameter is required.";
            if (!arguments.TryGetProperty("newPath", out var newPathEl))
                return "Error: 'newPath' parameter is required.";

            var oldPath = oldPathEl.GetString() ?? "";
            var newPath = newPathEl.GetString() ?? "";
            var preview = true;
            if (arguments.TryGetProperty("preview", out var previewEl))
                preview = previewEl.GetBoolean();

            _sendActivity($"MoveFile: {oldPath} -> {newPath}");

            var file = _workspaceAnalysis.AllFiles.FirstOrDefault(f =>
                f.RelativePath.Equals(oldPath, StringComparison.OrdinalIgnoreCase) ||
                f.RelativePath.Replace('\\', '/').Equals(oldPath.Replace('\\', '/'), StringComparison.OrdinalIgnoreCase));

            if (file == null)
                return $"Error: File not found: {oldPath}";

            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(preview ? "# Move File Preview" : "# Move File Result");
                sb.AppendLine();
                sb.AppendLine($"**From:** `{oldPath}`");
                sb.AppendLine($"**To:** `{newPath}`");
                sb.AppendLine();

                // Determine old and new namespaces from directory structure
                var oldNamespace = GetNamespaceFromPath(oldPath);
                var newNamespace = GetNamespaceFromPath(newPath);

                var affectedFiles = new List<string>();

                if (oldNamespace != newNamespace && !string.IsNullOrEmpty(oldNamespace))
                {
                    sb.AppendLine($"**Namespace change:** `{oldNamespace}` → `{newNamespace}`");
                    sb.AppendLine();

                    // Find files that reference types from the moved file
                    var typesInFile = file.Types.Select(t => t.Name).ToList();

                    foreach (var otherFile in _workspaceAnalysis.AllFiles.Where(f => f.Extension == ".cs" && f.FilePath != file.FilePath))
                    {
                        var content = File.ReadAllText(otherFile.FilePath);
                        bool needsUpdate = false;

                        // Check if file uses any types from the moved file
                        foreach (var typeName in typesInFile)
                        {
                            if (System.Text.RegularExpressions.Regex.IsMatch(content, $@"\b{typeName}\b"))
                            {
                                needsUpdate = true;
                                break;
                            }
                        }

                        // Check if file has using statement for old namespace
                        if (content.Contains($"using {oldNamespace};"))
                            needsUpdate = true;

                        if (needsUpdate)
                            affectedFiles.Add(otherFile.RelativePath);
                    }

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine("## Files that may need using statement updates");
                        foreach (var af in affectedFiles.Take(20))
                            sb.AppendLine($"- `{af}`");
                        if (affectedFiles.Count > 20)
                            sb.AppendLine($"- ... and {affectedFiles.Count - 20} more");
                        sb.AppendLine();
                    }
                }

                if (!preview)
                {
                    // Determine full paths
                    var oldDir = Path.GetDirectoryName(file.FilePath) ?? "";
                    var baseDir = oldDir;

                    // Walk up to find the base directory that matches the relative path structure
                    var relativeDir = Path.GetDirectoryName(oldPath.Replace('/', Path.DirectorySeparatorChar)) ?? "";
                    if (!string.IsNullOrEmpty(relativeDir))
                    {
                        baseDir = file.FilePath.Substring(0, file.FilePath.Length - oldPath.Length);
                    }

                    var newFullPath = Path.Combine(baseDir, newPath.Replace('/', Path.DirectorySeparatorChar));
                    var newDir = Path.GetDirectoryName(newFullPath);

                    // Create backup
                    File.Copy(file.FilePath, file.FilePath + ".bak", true);

                    // Ensure target directory exists
                    if (!string.IsNullOrEmpty(newDir) && !Directory.Exists(newDir))
                        Directory.CreateDirectory(newDir);

                    // Update namespace in the file if needed
                    if (oldNamespace != newNamespace && !string.IsNullOrEmpty(newNamespace))
                    {
                        var content = File.ReadAllText(file.FilePath);
                        if (!string.IsNullOrEmpty(oldNamespace))
                            content = content.Replace($"namespace {oldNamespace}", $"namespace {newNamespace}");
                        File.WriteAllText(file.FilePath, content);
                    }

                    // Move the file
                    File.Move(file.FilePath, newFullPath, true);

                    _log($"MoveFile: {oldPath} -> {newPath}");
                    _updateFileIndex(file.FilePath);
                    _updateFileIndex(newFullPath);

                    sb.AppendLine("**Status:** Moved successfully");
                    sb.AppendLine($"**Backup:** `{file.FilePath}.bak`");

                    if (affectedFiles.Count > 0)
                    {
                        sb.AppendLine();
                        sb.AppendLine("*Note: You may need to update using statements in the affected files listed above.*");
                    }
                }
                else
                {
                    sb.AppendLine("*This is a preview. Run with `preview: false` to apply the move.*");
                }

                return sb.ToString();
            }
            catch (Exception ex)
            {
                return $"Error: {ex.Message}";
            }
        }

        private string GetNamespaceFromPath(string relativePath)
        {
            var dir = Path.GetDirectoryName(relativePath);
            if (string.IsNullOrEmpty(dir))
                return string.Empty;

            // Convert path separators to dots and clean up
            return dir.Replace('/', '.').Replace('\\', '.').Trim('.');
        }
    }
}
